/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a commercial license.
 * You may not use this file except in compliance with the commercial license.
 */

package org.camunda.optimize.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import org.camunda.bpm.model.bpmn.Bpmn;
import org.camunda.bpm.model.bpmn.BpmnModelInstance;
import org.camunda.bpm.model.bpmn.GatewayDirection;
import org.camunda.bpm.model.bpmn.builder.AbstractFlowNodeBuilder;
import org.camunda.bpm.model.bpmn.builder.ProcessBuilder;
import org.camunda.bpm.model.bpmn.builder.StartEventBuilder;
import org.camunda.bpm.model.xml.instance.ModelElementInstance;
import org.camunda.optimize.dto.optimize.query.event.AutogeneratedEventGraphDto;
import org.camunda.optimize.dto.optimize.query.event.AutogeneratedProcessModelDto;
import org.camunda.optimize.dto.optimize.query.event.EventMappingDto;
import org.camunda.optimize.dto.optimize.query.event.EventSequenceCountDto;
import org.camunda.optimize.dto.optimize.query.event.EventSourceEntryDto;
import org.camunda.optimize.dto.optimize.query.event.EventSourceType;
import org.camunda.optimize.dto.optimize.query.event.EventTypeDto;
import org.camunda.optimize.service.es.OptimizeElasticsearchClient;
import org.camunda.optimize.service.es.reader.EventSequenceCountReader;
import org.camunda.optimize.service.util.configuration.ConfigurationService;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.camunda.optimize.upgrade.es.ElasticsearchConstants.EXTERNAL_EVENTS_INDEX_SUFFIX;

@Component
@Slf4j
public class AutogeneratedProcessModelService {

  private static final String AUTOGENERATED_PROCESS_ID = "AutogeneratedProcessId";
  private final EventSequenceCountReader externalEventSequenceCounter;

  public AutogeneratedProcessModelService(final OptimizeElasticsearchClient esClient,
                                          final ObjectMapper objectMapper,
                                          final ConfigurationService configurationService) {
    this.externalEventSequenceCounter = new EventSequenceCountReader(
      EXTERNAL_EVENTS_INDEX_SUFFIX,
      esClient,
      objectMapper,
      configurationService
    );
  }

  public AutogeneratedProcessModelDto generateModelFromEventSources(List<EventSourceEntryDto> eventSources) {
    // This will eventually be removed when support exists for Camunda sources and even mixed sources
    if (eventSources.stream().anyMatch(source -> source.getType().equals(EventSourceType.CAMUNDA))) {
      log.warn("Autogeneration is only supported for an external event source");
      return AutogeneratedProcessModelDto.builder().mappings(Collections.emptyMap()).build();
    }

    final AutogeneratedEventGraphDto autogeneratedEventGraphDto = generateExternalEventGraph();
    Map<String, EventMappingDto> mappings = new HashMap<>();
    if (autogeneratedEventGraphDto.getStartEvents().isEmpty()) {
      log.warn("Cannot generate a model as no eligible start events found");
      return AutogeneratedProcessModelDto.builder().mappings(mappings).build();
    }
    if (autogeneratedEventGraphDto.getEndEvents().isEmpty()) {
      log.warn("Cannot generate a model as no eligible end events found");
      return AutogeneratedProcessModelDto.builder().mappings(mappings).build();
    }

    ProcessBuilder diagramBuilder = Bpmn.createExecutableProcess(AUTOGENERATED_PROCESS_ID);
    autogeneratedEventGraphDto.getStartEvents().forEach(rootNode -> {
      final String nodeId = generateNodeId(rootNode);
      log.debug("Adding start event with id {} to autogenerated model", nodeId);
      StartEventBuilder startEventBuilder = diagramBuilder.startEvent(nodeId)
        .message(rootNode.getEventName())
        .name(rootNode.getEventName());
      mappings.put(nodeId, EventMappingDto.builder().start(rootNode).build());
      depthTraverseGraph(
        autogeneratedEventGraphDto.getSourceToTargetEventsMap().get(rootNode),
        autogeneratedEventGraphDto,
        startEventBuilder,
        mappings
      );
    });
    final BpmnModelInstance modelInstance = diagramBuilder.done();

    return AutogeneratedProcessModelDto.builder()
      .xml(Bpmn.convertToString(modelInstance))
      .mappings(mappings)
      .build();
  }

  private void depthTraverseGraph(List<EventTypeDto> nodesToAdd,
                                  AutogeneratedEventGraphDto graphDto,
                                  AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                  Map<String, EventMappingDto> mappings) {
    if (nodesToAdd.size() > 1) {
      log.debug("Adding diverging exclusive gateway to autogenerated model");
      currentNodeBuilder = currentNodeBuilder.exclusiveGateway().gatewayDirection(GatewayDirection.Diverging);
    }
    for (EventTypeDto nodeToAdd : nodesToAdd) {
      List<EventTypeDto> nextNodes = graphDto.getSourceToTargetEventsMap().get(nodeToAdd);
      BpmnModelInstance currentFlowNodeInstance = currentNodeBuilder.done();
      String nodeId = generateNodeId(nodeToAdd);
      ModelElementInstance existingModelElement = currentFlowNodeInstance.getModelElementById(nodeId);
      if (nextNodes.isEmpty()) {
        if (existingModelElement == null) {
          log.debug("Adding end event with id {} to autogenerated model", nodeId);
          currentNodeBuilder.endEvent(nodeId)
            .message(nodeToAdd.getEventName())
            .name(nodeToAdd.getEventName());
          mappings.put(nodeId, EventMappingDto.builder().start(nodeToAdd).build());
        } else {
          log.debug("Connecting to end event with id {}", nodeId);
          currentNodeBuilder.connectTo(nodeId);
        }
      } else {
        if (existingModelElement == null) {
          log.debug("Adding intermediate event with id {} to autogenerated model", nodeId);
          AbstractFlowNodeBuilder<?, ?> nextBuilder = currentNodeBuilder.intermediateCatchEvent(nodeId)
            .message(nodeToAdd.getEventName())
            .name(nodeToAdd.getEventName());
          mappings.put(nodeId, EventMappingDto.builder().start(nodeToAdd).build());
          depthTraverseGraph(nextNodes, graphDto, nextBuilder, mappings);
        } else {
          log.debug("Connecting to intermediate event with id {}", nodeId);
          currentNodeBuilder.connectTo(nodeId);
        }
      }
    }
  }

  private AutogeneratedEventGraphDto generateExternalEventGraph() {
    Map<EventTypeDto, List<EventTypeDto>> sourceToTargetEventsMap = new HashMap<>();
    final List<EventSequenceCountDto> externalEventSequenceCounts = externalEventSequenceCounter.getAllSequenceCounts();
    externalEventSequenceCounts
      .forEach(eventSequenceCountDto -> {
        if (eventSequenceCountDto.getTargetEvent() == null) {
          if (!sourceToTargetEventsMap.containsKey(eventSequenceCountDto.getSourceEvent())) {
            sourceToTargetEventsMap.put(eventSequenceCountDto.getSourceEvent(), new ArrayList<>());
          }
        } else {
          if (sourceToTargetEventsMap.containsKey(eventSequenceCountDto.getSourceEvent())) {
            sourceToTargetEventsMap.get(eventSequenceCountDto.getSourceEvent()).add(eventSequenceCountDto.getTargetEvent());
          } else {
            List<EventTypeDto> targetEvents = new ArrayList<>();
            targetEvents.add(eventSequenceCountDto.getTargetEvent());
            sourceToTargetEventsMap.put(eventSequenceCountDto.getSourceEvent(), targetEvents);
          }
        }
      });

    final List<EventTypeDto> targetEvents = sourceToTargetEventsMap.values()
      .stream()
      .flatMap(Collection::stream)
      .distinct()
      .collect(Collectors.toList());
    List<EventTypeDto> startEvents = new ArrayList<>(sourceToTargetEventsMap.keySet());
    startEvents.removeAll(targetEvents);
    List<EventTypeDto> endEvents = sourceToTargetEventsMap.keySet().stream()
      .filter(endNodeCandidate -> sourceToTargetEventsMap.get(endNodeCandidate).isEmpty())
      .collect(Collectors.toList());

    return AutogeneratedEventGraphDto.builder()
      .startEvents(startEvents)
      .endEvents(endEvents)
      .sourceToTargetEventsMap(sourceToTargetEventsMap)
      .build();
  }

  public static String generateNodeId(EventTypeDto eventTypeDto) {
    // The prefix is necessary so that the id passes QName validation
    return Strings.join(
      Arrays.asList("autogenerated", eventTypeDto.getGroup(), eventTypeDto.getSource(), eventTypeDto.getEventName()),
      "_"
    );
  }

}
