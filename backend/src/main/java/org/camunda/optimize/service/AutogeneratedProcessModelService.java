/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a commercial license.
 * You may not use this file except in compliance with the commercial license.
 */

package org.camunda.optimize.service;

import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.camunda.bpm.model.bpmn.Bpmn;
import org.camunda.bpm.model.bpmn.BpmnModelInstance;
import org.camunda.bpm.model.bpmn.GatewayDirection;
import org.camunda.bpm.model.bpmn.builder.AbstractFlowElementBuilder;
import org.camunda.bpm.model.bpmn.builder.AbstractFlowNodeBuilder;
import org.camunda.bpm.model.bpmn.builder.ProcessBuilder;
import org.camunda.bpm.model.bpmn.builder.StartEventBuilder;
import org.camunda.bpm.model.xml.instance.ModelElementInstance;
import org.camunda.optimize.dto.optimize.query.event.AdjacentEventTypesDto;
import org.camunda.optimize.dto.optimize.query.event.AutogeneratedEventGraphDto;
import org.camunda.optimize.dto.optimize.query.event.AutogeneratedProcessModelDto;
import org.camunda.optimize.dto.optimize.query.event.EventMappingDto;
import org.camunda.optimize.dto.optimize.query.event.EventSourceEntryDto;
import org.camunda.optimize.dto.optimize.query.event.EventSourceType;
import org.camunda.optimize.dto.optimize.query.event.EventTypeDto;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.stream.Collectors.groupingBy;
import static org.camunda.bpm.model.bpmn.GatewayDirection.Converging;
import static org.camunda.bpm.model.bpmn.GatewayDirection.Diverging;

@AllArgsConstructor
@Component
@Slf4j
public class AutogeneratedProcessModelService {

  private static final String AUTOGENERATED_PROCESS_ID = "AutogeneratedProcessId";
  private static final String EVENT = "event";
  private static final String DIVERGING_GATEWAY = "Diverging gateway";

  private final ExternalEventGraphService externalEventGraphService;

  public AutogeneratedProcessModelDto generateModelFromEventSources(List<EventSourceEntryDto> eventSources) {
    // This will eventually be removed when support exists for Camunda sources and even mixed sources
    if (eventSources.stream().anyMatch(source -> source.getType().equals(EventSourceType.CAMUNDA))) {
      log.warn("Autogeneration is only supported for an external event source");
      return createEmptyProcessModel();
    }

    final AutogeneratedEventGraphDto autogeneratedEventGraphDto =
      externalEventGraphService.generateExternalEventGraph();
    if (autogeneratedEventGraphDto.getStartEvents().isEmpty()) {
      log.warn("Cannot generate a model as no eligible start events found");
      return createEmptyProcessModel();
    }
    if (autogeneratedEventGraphDto.getEndEvents().isEmpty()) {
      log.warn("Cannot generate a model as no eligible end events found");
      return createEmptyProcessModel();
    }

    Map<String, EventMappingDto> mappings = new HashMap<>();
    ProcessBuilder diagramBuilder = Bpmn.createExecutableProcess(AUTOGENERATED_PROCESS_ID);
    autogeneratedEventGraphDto.getStartEvents().forEach(rootNode -> {
      final String nodeId = generateNodeId(rootNode);
      log.debug("Adding start event with id {} to autogenerated model", nodeId);
      StartEventBuilder startEventBuilder = diagramBuilder.startEvent(nodeId)
        .message(rootNode.getEventName())
        .name(rootNode.getEventName());
      mappings.put(nodeId, EventMappingDto.builder().start(rootNode).build());
      depthTraverseGraph(
        rootNode,
        autogeneratedEventGraphDto.getAdjacentEventTypesDtoMap().get(rootNode).getSucceedingEvents(),
        autogeneratedEventGraphDto,
        startEventBuilder,
        mappings
      );
    });
    final BpmnModelInstance modelInstance = diagramBuilder.done();

    return AutogeneratedProcessModelDto.builder()
      .xml(Bpmn.convertToString(modelInstance))
      .mappings(mappings)
      .build();
  }

  private void depthTraverseGraph(EventTypeDto previouslyAddedNode,
                                  List<EventTypeDto> nodesToAdd,
                                  AutogeneratedEventGraphDto graphDto,
                                  AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                  Map<String, EventMappingDto> mappings) {
    for (EventTypeDto nodeToAdd : nodesToAdd) {
      final Optional<String> precedingDivergingGatewayId = getPrecedingDivergingGatewayId(nodeToAdd, graphDto);
      if (precedingDivergingGatewayId.isPresent() &&
        !nodeAlreadyAddedToModel(precedingDivergingGatewayId.get(), currentNodeBuilder)) {
        currentNodeBuilder = addGateway(currentNodeBuilder, previouslyAddedNode, Diverging, graphDto);
      }
      if (graphDto.getEndEvents().contains(nodeToAdd)) {
        currentNodeBuilder = addOrConnectToEndNode(graphDto, currentNodeBuilder, mappings, nodeToAdd);
      } else {
        if (!nodesExistInParallel(nodeToAdd, previouslyAddedNode, graphDto)) {
          currentNodeBuilder = addOrConnectToIntermediateEventNode(graphDto, currentNodeBuilder, mappings, nodeToAdd);
        } else {
          depthTraverseOrConnect(graphDto, currentNodeBuilder, mappings, nodeToAdd);
        }
      }
    }
  }

  private AbstractFlowNodeBuilder<?, ?> addOrConnectToIntermediateEventNode(final AutogeneratedEventGraphDto graphDto,
                                                                            AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                                                            final Map<String, EventMappingDto> mappings,
                                                                            final EventTypeDto nodeToAdd) {
    final String nodeId = generateNodeId(nodeToAdd);
    if (!nodeAlreadyAddedToModel(nodeId, currentNodeBuilder)) {
      if (nodeSucceedsConvergingGateway(nodeToAdd, graphDto)) {
        currentNodeBuilder = addGateway(currentNodeBuilder, nodeToAdd, Converging, graphDto);
      }
      AbstractFlowNodeBuilder<?, ?> nextBuilder = addIntermediateEvent(currentNodeBuilder, nodeToAdd, nodeId);
      mappings.put(nodeId, EventMappingDto.builder().start(nodeToAdd).build());
      depthTraverseOrConnect(graphDto, nextBuilder, mappings, nodeToAdd);
    } else {
      connectToExistingNode(currentNodeBuilder, nodeToAdd);
    }
    return currentNodeBuilder;
  }

  private void connectToExistingNode(final AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                     final EventTypeDto nodeToConnectTo) {
    final String existingGatewayId = generateGatewayIdForNode(nodeToConnectTo, Converging);
    if (nodeAlreadyAddedToModel(existingGatewayId, currentNodeBuilder)) {
      log.debug("Connecting to gateway with id {}", existingGatewayId);
      currentNodeBuilder.connectTo(existingGatewayId);
    } else {
      // If the gateway hasn't been added, we connect directly to the node
      log.debug("Connecting to node with id {}", existingGatewayId);
      currentNodeBuilder.connectTo(generateNodeId(nodeToConnectTo));
    }
  }

  private void depthTraverseOrConnect(final AutogeneratedEventGraphDto graphDto,
                                      final AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                      final Map<String, EventMappingDto> mappings,
                                      final EventTypeDto nodeToAdd) {
    final List<EventTypeDto> succeedingEvents = graphDto.getAdjacentEventTypesDtoMap()
      .get(nodeToAdd).getSucceedingEvents();
    final List<EventTypeDto> nonParallel = succeedingEvents
      .stream()
      .filter(nextNode -> !nodesExistInParallel(nextNode, nodeToAdd, graphDto))
      .collect(Collectors.toList());
    if (!nonParallel.isEmpty()) {
      depthTraverseGraph(nodeToAdd, nonParallel, graphDto, currentNodeBuilder, mappings);
    } else {
      // if we can't find a non-parallel nodes, we try to connect to any already modelled next nodes
      final Optional<EventTypeDto> nodeToConnect = findAlreadyModelledNextNodeId(currentNodeBuilder, succeedingEvents);
      if (nodeToConnect.isPresent()) {
        final EventTypeDto nextNode = nodeToConnect.get();
        log.debug(
          "Could not find a non-parallel next node after node with id {}, connecting to {}",
          generateNodeId(nodeToAdd),
          generateNodeId(nextNode)
        );
        connectToExistingNode(currentNodeBuilder, nextNode);
      } else {
        // We've run out of options now, so we just leave an orphaned node
        log.debug("Cannot connect node {} to its next node as it could not be found", generateNodeId(nodeToAdd));
      }
    }
  }

  private AbstractFlowNodeBuilder<?, ?> addOrConnectToEndNode(final AutogeneratedEventGraphDto graphDto,
                                                              AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                                              final Map<String, EventMappingDto> mappings,
                                                              final EventTypeDto nodeToAdd) {
    final String nodeId = generateNodeId(nodeToAdd);
    if (!nodeAlreadyAddedToModel(nodeId, currentNodeBuilder)) {
      if (nodeSucceedsConvergingGateway(nodeToAdd, graphDto)) {
        currentNodeBuilder = addGateway(currentNodeBuilder, nodeToAdd, Converging, graphDto);
      }
      addEndEvent(currentNodeBuilder, nodeToAdd, nodeId);
      mappings.put(nodeId, EventMappingDto.builder().start(nodeToAdd).build());
    } else {
      final String existingGatewayId = generateGatewayIdForNode(nodeToAdd, Converging);
      // In some cases, there may not be a gateway
      if (nodeSucceedsConvergingGateway(nodeToAdd, graphDto)
        && nodeAlreadyAddedToModel(existingGatewayId, currentNodeBuilder)) {
        log.debug("Connecting to gateway with id {}", existingGatewayId);
        currentNodeBuilder.connectTo(existingGatewayId);
      } else {
        // If the gateway hasn't been added, we connect directly to the node
        log.debug("Connecting to end event with id {}", nodeId);
        currentNodeBuilder.connectTo(nodeId);
      }
    }
    return currentNodeBuilder;
  }

  private Optional<EventTypeDto> findAlreadyModelledNextNodeId(final AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                                               final List<EventTypeDto> nextNodes) {
    for (EventTypeDto nextNode : nextNodes) {
      final String nextNodeId = generateNodeId(nextNode);
      if (nodeAlreadyAddedToModel(nextNodeId, currentNodeBuilder)) {
        return Optional.of(nextNode);
      }
    }
    return Optional.empty();
  }

  private AbstractFlowNodeBuilder<?, ?> addIntermediateEvent(final AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                                             final EventTypeDto nodeToAdd, final String nodeId) {
    log.debug("Adding intermediate event with id {} to autogenerated model", nodeId);
    return currentNodeBuilder.intermediateCatchEvent(nodeId)
      .message(nodeToAdd.getEventName())
      .name(nodeToAdd.getEventName());
  }

  private AbstractFlowElementBuilder<?, ?> addEndEvent(final AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                                       final EventTypeDto nodeToAdd, final String nodeId) {
    log.debug("Adding end event with id {} to autogenerated model", nodeId);
    return currentNodeBuilder.endEvent(nodeId)
      .message(nodeToAdd.getEventName())
      .name(nodeToAdd.getEventName());
  }

  private AbstractFlowNodeBuilder<?, ?> addGateway(AbstractFlowNodeBuilder<?, ?> currentNodeBuilder,
                                                   final EventTypeDto nodeToAdd,
                                                   final GatewayDirection gatewayDirection,
                                                   final AutogeneratedEventGraphDto graphDto) {
    final List<EventTypeDto> adjacentEventsToLookup;
    final AdjacentEventTypesDto adjacentEventTypesDto = graphDto.getAdjacentEventTypesDtoMap().get(nodeToAdd);
    if (Diverging.equals(gatewayDirection)) {
      adjacentEventsToLookup = adjacentEventTypesDto.getSucceedingEvents();
    } else {
      adjacentEventsToLookup = adjacentEventTypesDto.getPrecedingEvents();
    }
    final Map<Integer, Long> traceCountsByAdjacentEventOccurrence =
      extractEventTraceCountByAdjacentEventOccurrence(nodeToAdd, gatewayDirection, adjacentEventsToLookup, graphDto);
    final String gatewayId = generateGatewayIdForNode(nodeToAdd, gatewayDirection);

    final boolean isParallelGateway = traceCountsByAdjacentEventOccurrence.get(adjacentEventsToLookup.size()) != null
      && traceCountsByAdjacentEventOccurrence.size() == 1;
    final boolean isExclusiveGateway = traceCountsByAdjacentEventOccurrence.get(1) != null
      && traceCountsByAdjacentEventOccurrence.size() == 1;
    if (isParallelGateway) {
      log.debug("Adding {} parallel gateway with id {} to model", gatewayDirection.toString(), gatewayId);
      currentNodeBuilder = currentNodeBuilder.parallelGateway(gatewayId);
    } else if (isExclusiveGateway) {
      log.debug("Adding {} exclusive gateway with id {} to model", gatewayDirection.toString(), gatewayId);
      currentNodeBuilder = Diverging.equals(gatewayDirection) ?
        currentNodeBuilder.exclusiveGateway(gatewayId).name(DIVERGING_GATEWAY) :
        currentNodeBuilder.exclusiveGateway(gatewayId);
    } else {
      log.debug("Could not determine a gateway type for gateway with id {}, default to inclusive", gatewayId);
      currentNodeBuilder = Diverging.equals(gatewayDirection) ?
        currentNodeBuilder.inclusiveGateway(gatewayId).name(DIVERGING_GATEWAY) :
        currentNodeBuilder.inclusiveGateway(gatewayId);
    }
    return currentNodeBuilder;
  }

  private Map<Integer, Long> extractEventTraceCountByAdjacentEventOccurrence(final EventTypeDto nodeToAdd,
                                                                             final GatewayDirection gatewayDirection,
                                                                             final List<EventTypeDto> adjacentEventsToLookup,
                                                                             final AutogeneratedEventGraphDto graphDto) {
    return graphDto.getSampleAsTypeLists().stream()
      .filter(eventTypeTrace -> eventTypeTrace.contains(nodeToAdd))
      .map(eventTrace -> {
        if (Diverging.equals(gatewayDirection)) {
          // if diverging, we only care about the occurrences of adjacent events after the last occurring target event
          return eventTrace.subList(eventTrace.lastIndexOf(nodeToAdd), eventTrace.size());
        } else {
          // if converging, we only care about the occurrences of adjacent events before the first occurring target
          // event
          return eventTrace.subList(0, eventTrace.indexOf(nodeToAdd));
        }
      })
      .collect(groupingBy(
        trace -> CollectionUtils.intersection(trace, adjacentEventsToLookup).size(),
        Collectors.counting()
      ));
  }

  private boolean nodeAlreadyAddedToModel(final String nodeId, AbstractFlowNodeBuilder<?, ?> currentNodeBuilder) {
    BpmnModelInstance currentFlowNodeInstance = currentNodeBuilder.done();
    ModelElementInstance existingModelElement = currentFlowNodeInstance.getModelElementById(nodeId);
    return existingModelElement != null;
  }

  private boolean nodeSucceedsConvergingGateway(final EventTypeDto node, final AutogeneratedEventGraphDto graphDto) {
    return getPrecedingNodes(node, graphDto).size() > 1;
  }

  private Optional<String> getPrecedingDivergingGatewayId(final EventTypeDto node,
                                                          final AutogeneratedEventGraphDto graphDto) {
    final List<Map.Entry<EventTypeDto, AdjacentEventTypesDto>> precedingNodes = getPrecedingNodes(node, graphDto);
    if (precedingNodes.size() == 1 && precedingNodes.get(0).getValue().getSucceedingEvents().size() > 1) {
      return Optional.of(generateGatewayIdForNode(precedingNodes.get(0).getKey(), Diverging));
    }
    return Optional.empty();
  }

  private List<Map.Entry<EventTypeDto, AdjacentEventTypesDto>> getPrecedingNodes(final EventTypeDto node,
                                                                                 final AutogeneratedEventGraphDto graphDto) {
    return graphDto.getAdjacentEventTypesDtoMap()
      .entrySet()
      .stream()
      .filter(entry -> entry.getValue().getSucceedingEvents().contains(node))
      .filter(entry -> !graphDto.getAdjacentEventTypesDtoMap()
        .get(node)
        .getSucceedingEvents()
        .contains(entry.getKey()))
      .collect(Collectors.toList());
  }

  private boolean nodesExistInParallel(final EventTypeDto nodeToAdd,
                                       final EventTypeDto alreadyAddedNode,
                                       final AutogeneratedEventGraphDto graphDto) {
    // if a node is adjacent to a gateway, we can try to determine whether it is part of a parallel path to the
    // previously added node to avoid additional redundant gateway creation

    // if either node are start or end events, they are not parallel
    final boolean startOrEnd = Stream.concat(graphDto.getStartEvents().stream(), graphDto.getEndEvents().stream())
      .anyMatch(event -> event.equals(nodeToAdd) || event.equals(alreadyAddedNode));
    if (startOrEnd) {
      return false;
    }

    // if  both nodes precede and succeed each other in our trace samples, they are parallel
    final List<List<EventTypeDto>> containsBothEvents = graphDto.getSampleAsTypeLists().stream()
      .filter(eventTrace -> eventTrace.containsAll(Arrays.asList(nodeToAdd, alreadyAddedNode)))
      .collect(Collectors.toList());
    final boolean aBeforeB = containsBothEvents.stream()
      .anyMatch(trace -> trace.indexOf(nodeToAdd) == trace.indexOf(alreadyAddedNode) + 1);
    final boolean bBeforeA = containsBothEvents.stream()
      .anyMatch(trace -> trace.indexOf(alreadyAddedNode) == trace.indexOf(nodeToAdd) + 1);
    if (aBeforeB && bBeforeA) {
      return true;
    }

    // If both nodes share a preceding diverging gateway, we know they are parallel
    return getPrecedingDivergingGatewayId(nodeToAdd, graphDto)
      .map(gatewayId -> {
        final Optional<String> existingGatewayId = getPrecedingDivergingGatewayId(alreadyAddedNode, graphDto);
        return existingGatewayId.isPresent() && existingGatewayId.get().equals(gatewayId);
      }).orElse(false);
  }

  public static String generateGatewayIdForNode(final EventTypeDto eventTypeDto, GatewayDirection gatewayDirection) {
    return generateId(gatewayDirection.toString().toLowerCase(), eventTypeDto);
  }

  public static String generateNodeId(final EventTypeDto eventTypeDto) {
    return generateId(EVENT, eventTypeDto);
  }

  private AutogeneratedProcessModelDto createEmptyProcessModel() {
    return AutogeneratedProcessModelDto.builder()
      .xml(Bpmn.convertToString(Bpmn.createExecutableProcess(AUTOGENERATED_PROCESS_ID).done()))
      .mappings(Collections.emptyMap())
      .build();
  }

  private static String generateId(String type, EventTypeDto eventTypeDto) {
    // The type prefix is necessary and should start with lower case so that the ID passes QName validation
    return String.join(
      "_",
      Arrays.asList(
        type,
        eventTypeDto.getGroup(),
        eventTypeDto.getSource(),
        eventTypeDto.getEventName()
      )
    );
  }

}
