/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a commercial license.
 * You may not use this file except in compliance with the commercial license.
 */
package org.camunda.optimize.service.util;

import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import org.camunda.bpm.model.bpmn.BpmnModelInstance;
import org.camunda.bpm.model.bpmn.GatewayDirection;
import org.camunda.bpm.model.bpmn.builder.AbstractFlowNodeBuilder;
import org.camunda.bpm.model.bpmn.builder.EndEventBuilder;
import org.camunda.bpm.model.bpmn.builder.ExclusiveGatewayBuilder;
import org.camunda.bpm.model.bpmn.builder.InclusiveGatewayBuilder;
import org.camunda.bpm.model.bpmn.builder.IntermediateCatchEventBuilder;
import org.camunda.bpm.model.bpmn.builder.ParallelGatewayBuilder;
import org.camunda.bpm.model.bpmn.builder.ProcessBuilder;
import org.camunda.bpm.model.bpmn.builder.StartEventBuilder;
import org.camunda.bpm.model.bpmn.instance.EndEvent;
import org.camunda.bpm.model.bpmn.instance.ExclusiveGateway;
import org.camunda.bpm.model.bpmn.instance.InclusiveGateway;
import org.camunda.bpm.model.bpmn.instance.IntermediateCatchEvent;
import org.camunda.bpm.model.bpmn.instance.ParallelGateway;
import org.camunda.bpm.model.bpmn.instance.StartEvent;
import org.camunda.optimize.dto.optimize.query.event.EventSourceEntryDto;
import org.camunda.optimize.dto.optimize.query.event.EventTypeDto;

import java.util.Arrays;
import java.util.List;

import static org.camunda.bpm.model.bpmn.GatewayDirection.Diverging;

@Slf4j
@UtilityClass
public class EventModelBuilderUtil {

  private static final String EVENT = "event";
  private static final String PROCESS = "process";
  private static final String CONNECTING = "connecting";
  private static final String DIVERGING_GATEWAY = "Diverging gateway";
  private static final String CONVERGING_GATEWAY = "Converging gateway";
  private static final String CONNECTING_GATEWAY = "Connecting gateway";

  public static String generateNodeId(final EventTypeDto eventTypeDto) {
    return removeIllegalCharacters(generateId(EVENT, eventTypeDto));
  }

  public static String generateGatewayIdForNode(final EventTypeDto eventTypeDto, GatewayDirection gatewayDirection) {
    return removeIllegalCharacters(generateId(gatewayDirection.toString().toLowerCase(), eventTypeDto));
  }

  public static String generateModelGatewayIdForSource(final EventSourceEntryDto eventSourceEntryDto,
                                                       final GatewayDirection gatewayDirection) {
    return String.join(
      "_",
      Arrays.asList(gatewayDirection.toString().toLowerCase(), eventSourceEntryDto.getProcessDefinitionKey())
    );
  }

  public static String generateConnectionGatewayIdForDefinitionKey(final String definitionKey) {
    return String.join(
      "_",
      Arrays.asList(CONNECTING, definitionKey)
    );
  }

  public static String generateTaskIdForDefinitionKey(final String definitionKey) {
    return String.join(
      "_",
      Arrays.asList(PROCESS, definitionKey)
    );
  }

  public static AbstractFlowNodeBuilder<StartEventBuilder, StartEvent> addStartEvent(final EventTypeDto event,
                                                                                     final String nodeId,
                                                                                     final ProcessBuilder processBuilder) {
    log.debug("Adding start event node with id {} to autogenerated model", nodeId);
    return processBuilder.startEvent(nodeId)
      .message(IdGenerator.getNextId())
      .name(event.getEventName());
  }

  public static AbstractFlowNodeBuilder<IntermediateCatchEventBuilder, IntermediateCatchEvent> addIntermediateEvent(
    final EventTypeDto event,
    final String nodeId,
    final AbstractFlowNodeBuilder<?, ?> currentBuilder) {
    log.debug("Adding intermediate event node with id {} to autogenerated model", nodeId);
    return currentBuilder.intermediateCatchEvent(nodeId)
      .message(IdGenerator.getNextId())
      .name(event.getEventName());
  }

  public static AbstractFlowNodeBuilder<EndEventBuilder, EndEvent> addEndEvent(final EventTypeDto event,
                                                                               final String nodeId,
                                                                               final AbstractFlowNodeBuilder<?, ?> currentBuilder) {
    log.debug("Adding end event node with id {} to autogenerated model", nodeId);
    return currentBuilder.endEvent(nodeId)
      .message(IdGenerator.getNextId())
      .name(event.getEventName());
  }

  public static AbstractFlowNodeBuilder<ExclusiveGatewayBuilder, ExclusiveGateway> addConnectionGateway(
    final String gatewayId,
    final AbstractFlowNodeBuilder<?, ?> currentBuilder) {
    log.debug("Adding connecting exclusive gateway with id {} and to model", gatewayId);
    return currentBuilder.exclusiveGateway(gatewayId).name(CONNECTING_GATEWAY);
  }

  public static AbstractFlowNodeBuilder<ExclusiveGatewayBuilder, ExclusiveGateway> addExclusiveGateway(
    final GatewayDirection gatewayDirection,
    final String nodeId,
    final AbstractFlowNodeBuilder<?, ?> currentBuilder) {
    log.debug("Adding {} parallel gateway with id {} and to model", gatewayDirection.toString(), nodeId);
    return currentBuilder.exclusiveGateway(nodeId).name(getGatewayName(gatewayDirection));
  }

  public static AbstractFlowNodeBuilder<ParallelGatewayBuilder, ParallelGateway> addParallelGateway(
    final GatewayDirection gatewayDirection,
    final String nodeId,
    final AbstractFlowNodeBuilder<?, ?> currentBuilder) {
    log.debug("Adding {} parallel gateway with id {} and to model", gatewayDirection.toString(), nodeId);
    return currentBuilder.parallelGateway(nodeId).name(getGatewayName(gatewayDirection));
  }

  public static AbstractFlowNodeBuilder<InclusiveGatewayBuilder, InclusiveGateway> addInclusiveGateway(
    final GatewayDirection gatewayDirection,
    final String nodeId,
    final AbstractFlowNodeBuilder<?, ?> currentBuilder) {
    log.debug("Adding {} inclusive gateway with id {} and to model", gatewayDirection.toString(), nodeId);
    return currentBuilder.inclusiveGateway(nodeId).name(getGatewayName(gatewayDirection));
  }

  public static AbstractFlowNodeBuilder<?, ?> prepareModelBuilderForNextSource(AbstractFlowNodeBuilder<?, ?> builderToReturn,
                                                                               final List<EventTypeDto> endEventsInModel,
                                                                               final String definitionKey) {
    if (endEventsInModel.size() > 1) {
      final String connectionGatewayId = generateConnectionGatewayIdForDefinitionKey(definitionKey);
      for (EventTypeDto endEvent : endEventsInModel) {
        builderToReturn = builderToReturn.moveToNode(generateNodeId(endEvent));
        final BpmnModelInstance endEventBuilder = builderToReturn.done();
        if (endEventBuilder.getModelElementById(connectionGatewayId) == null) {
          addConnectionGateway(connectionGatewayId, builderToReturn);
        } else {
          builderToReturn.connectTo(connectionGatewayId);
        }
      }
      return builderToReturn.moveToNode(connectionGatewayId);
    } else if (endEventsInModel.size() == 1) {
      return builderToReturn.moveToNode(generateNodeId(endEventsInModel.get(0)));
    }
    log.warn("Cannot move builder to end of source model as no end events exist");
    return builderToReturn;
  }

  private static String getGatewayName(final GatewayDirection gatewayDirection) {
    return Diverging.equals(gatewayDirection) ? DIVERGING_GATEWAY : CONVERGING_GATEWAY;
  }

  private static String generateId(String type, EventTypeDto eventTypeDto) {
    // The type prefix is necessary and should start with lower case so that the ID passes QName validation
    return String.join(
      "_",
      Arrays.asList(
        type,
        eventTypeDto.getGroup(),
        eventTypeDto.getSource(),
        eventTypeDto.getEventName()
      )
    );
  }

  private static String removeIllegalCharacters(String originalId) {
    return originalId.replaceAll("\\s", "-").replaceAll("[^a-zA-Z0-9_.-]", "-");
  }

}
