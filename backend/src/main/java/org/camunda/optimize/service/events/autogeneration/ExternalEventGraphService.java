/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a commercial license.
 * You may not use this file except in compliance with the commercial license.
 */

package org.camunda.optimize.service.events.autogeneration;

import org.camunda.optimize.dto.optimize.query.event.AdjacentEventTypesDto;
import org.camunda.optimize.dto.optimize.query.event.AutogeneratedEventGraphDto;
import org.camunda.optimize.dto.optimize.query.event.EventSequenceCountDto;
import org.camunda.optimize.dto.optimize.query.event.EventTraceStateDto;
import org.camunda.optimize.dto.optimize.query.event.EventTypeDto;
import org.camunda.optimize.service.EventTraceStateService;
import org.camunda.optimize.service.EventTraceStateServiceFactory;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static java.util.stream.Collectors.groupingBy;
import static org.camunda.optimize.upgrade.es.ElasticsearchConstants.EXTERNAL_EVENTS_INDEX_SUFFIX;

@Component
public class ExternalEventGraphService {

  private static final int MAX_SAMPLE_RESULTS = 200;

  private final EventTraceStateService eventTraceStateService;

  public ExternalEventGraphService(EventTraceStateServiceFactory eventTraceStateServiceFactory) {
    this.eventTraceStateService = eventTraceStateServiceFactory.createEventTraceStateService(
      EXTERNAL_EVENTS_INDEX_SUFFIX);
  }

  public AutogeneratedEventGraphDto generateExternalEventGraph() {
    Map<EventTypeDto, AdjacentEventTypesDto> adjacentEventTypesDtoMap = new HashMap<>();
    final List<EventSequenceCountDto> externalEventSequenceCounts = eventTraceStateService.getAllSequenceCounts();
    externalEventSequenceCounts
      .forEach(eventSequenceCountDto -> {
        if (eventSequenceCountDto.getTargetEvent() == null) {
          if (!adjacentEventTypesDtoMap.containsKey(eventSequenceCountDto.getSourceEvent())) {
            adjacentEventTypesDtoMap.put(
              eventSequenceCountDto.getSourceEvent(),
              AdjacentEventTypesDto.builder().build()
            );
          }
        } else {
          if (adjacentEventTypesDtoMap.containsKey(eventSequenceCountDto.getSourceEvent())) {
            adjacentEventTypesDtoMap.get(eventSequenceCountDto.getSourceEvent())
              .getSucceedingEvents()
              .add(eventSequenceCountDto.getTargetEvent());
          } else {
            List<EventTypeDto> targetEvents = new ArrayList<>();
            targetEvents.add(eventSequenceCountDto.getTargetEvent());
            adjacentEventTypesDtoMap.put(
              eventSequenceCountDto.getSourceEvent(),
              AdjacentEventTypesDto.builder().succeedingEvents(targetEvents).build()
            );
          }
          if (adjacentEventTypesDtoMap.containsKey(eventSequenceCountDto.getTargetEvent())) {
            adjacentEventTypesDtoMap.get(eventSequenceCountDto.getTargetEvent())
              .getPrecedingEvents()
              .add(eventSequenceCountDto.getSourceEvent());
          } else {
            List<EventTypeDto> sourceEvents = new ArrayList<>();
            sourceEvents.add(eventSequenceCountDto.getSourceEvent());
            adjacentEventTypesDtoMap.put(
              eventSequenceCountDto.getTargetEvent(),
              AdjacentEventTypesDto.builder().precedingEvents(sourceEvents).build()
            );
          }
        }
      });

    final List<EventTypeDto> startEvents = identifyAndPromoteBestFitStartEvents(adjacentEventTypesDtoMap);
    final List<EventTypeDto> endEvents = identifyAndPromoteBestFitEndEvents(adjacentEventTypesDtoMap, startEvents);

    final List<EventTraceStateDto> completedTraceSample = getRandomTraceSamplesContainingEventFromEach(
      startEvents,
      endEvents
    );
    return AutogeneratedEventGraphDto.builder()
      .startEvents(startEvents)
      .endEvents(endEvents)
      .adjacentEventTypesDtoMap(adjacentEventTypesDtoMap)
      .sampleAsTypeLists(getTracesAsTypeLists(completedTraceSample))
      .build();
  }

  private List<EventTypeDto> identifyAndPromoteBestFitStartEvents(final Map<EventTypeDto, AdjacentEventTypesDto> adjacentEventTypesDtoMap) {
    final Map<Integer, List<Map.Entry<EventTypeDto, AdjacentEventTypesDto>>> adjacentEventsByPrecedingEventCount =
      adjacentEventTypesDtoMap.entrySet()
        .stream()
        .collect(groupingBy(entry -> entry.getValue().getPrecedingEvents().size()));
    List<EventTypeDto> startEvents = adjacentEventsByPrecedingEventCount.keySet()
      .stream()
      .min(Integer::compareTo)
      .map(minKey -> adjacentEventsByPrecedingEventCount.get(minKey)
        .stream()
        .map(Map.Entry::getKey)
        .collect(Collectors.toList())
      )
      .orElse(Collections.emptyList());
    // We make the adjacency Map consistent with the start event selection
    startEvents.forEach(startEvent -> {
      adjacentEventTypesDtoMap.get(startEvent).setPrecedingEvents(Collections.emptyList());
      adjacentEventTypesDtoMap.forEach((k, v) -> v.getSucceedingEvents().remove(startEvent));
    });
    return startEvents;
  }

  private List<EventTypeDto> identifyAndPromoteBestFitEndEvents(final Map<EventTypeDto, AdjacentEventTypesDto> adjacentEventTypesDtoMap,
                                                                final List<EventTypeDto> startEvents) {
    final Map<Integer, List<Map.Entry<EventTypeDto, AdjacentEventTypesDto>>> adjacentEventsBySucceedingEventCount =
      adjacentEventTypesDtoMap.entrySet()
        .stream()
        .collect(groupingBy(entry -> entry.getValue().getSucceedingEvents().size()));
    final List<EventTypeDto> endEvents = adjacentEventsBySucceedingEventCount.keySet().stream().min(Integer::compareTo)
      .map(minKey -> adjacentEventsBySucceedingEventCount.get(minKey)
        .stream()
        .map(Map.Entry::getKey)
        .collect(Collectors.toList())
      ).orElse(Collections.emptyList())
      .stream()
      .filter(endEventCandidate -> !startEvents.contains(endEventCandidate))
      .collect(Collectors.toList());
    // We make the adjacency Map consistent with the end event selection
    endEvents.forEach(endEvent -> {
      adjacentEventTypesDtoMap.get(endEvent).setSucceedingEvents(Collections.emptyList());
      adjacentEventTypesDtoMap.forEach((k, v) -> v.getPrecedingEvents().remove(endEvent));
    });
    return endEvents;
  }

  private List<EventTraceStateDto> getRandomTraceSamplesContainingEventFromEach(final List<EventTypeDto> startEvents,
                                                                                final List<EventTypeDto> endEvents) {
    return eventTraceStateService.getTracesContainingAtLeastOneEventFromEach(
      startEvents,
      endEvents,
      MAX_SAMPLE_RESULTS
    );
  }

  private List<List<EventTypeDto>> getTracesAsTypeLists(final List<EventTraceStateDto> eventTraces) {
    return eventTraces
      .stream()
      .map(trace -> trace.getEventTrace().stream()
        .map(event -> EventTypeDto.builder()
          .group(event.getGroup())
          .source(event.getSource())
          .eventName(event.getEventName())
          .build()
        )
        .collect(Collectors.toList()))
      .collect(Collectors.toList());
  }

}
