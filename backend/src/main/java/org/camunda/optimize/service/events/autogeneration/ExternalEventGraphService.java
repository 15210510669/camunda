/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a commercial license.
 * You may not use this file except in compliance with the commercial license.
 */

package org.camunda.optimize.service.events.autogeneration;

import org.camunda.optimize.dto.optimize.query.event.AdjacentEventTypesDto;
import org.camunda.optimize.dto.optimize.query.event.AutogeneratedEventGraphDto;
import org.camunda.optimize.dto.optimize.query.event.EventSequenceCountDto;
import org.camunda.optimize.dto.optimize.query.event.EventTraceStateDto;
import org.camunda.optimize.dto.optimize.query.event.EventTypeDto;
import org.camunda.optimize.service.EventTraceStateService;
import org.camunda.optimize.service.EventTraceStateServiceFactory;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.camunda.optimize.upgrade.es.ElasticsearchConstants.EXTERNAL_EVENTS_INDEX_SUFFIX;

@Component
public class ExternalEventGraphService {

  private static final int MAX_SAMPLE_RESULTS = 200;

  private final EventTraceStateService eventTraceStateService;

  public ExternalEventGraphService(EventTraceStateServiceFactory eventTraceStateServiceFactory) {
    this.eventTraceStateService = eventTraceStateServiceFactory.createEventTraceStateService(
      EXTERNAL_EVENTS_INDEX_SUFFIX);
  }

  public AutogeneratedEventGraphDto generateExternalEventGraph() {
    Map<EventTypeDto, AdjacentEventTypesDto> adjacentEventTypesDtoMap = new HashMap<>();
    final List<EventSequenceCountDto> externalEventSequenceCounts = eventTraceStateService.getAllSequenceCounts();
    externalEventSequenceCounts
      .forEach(eventSequenceCountDto -> {
        if (eventSequenceCountDto.getTargetEvent() == null) {
          if (!adjacentEventTypesDtoMap.containsKey(eventSequenceCountDto.getSourceEvent())) {
            adjacentEventTypesDtoMap.put(
              eventSequenceCountDto.getSourceEvent(),
              AdjacentEventTypesDto.builder().build()
            );
          }
        } else {
          if (adjacentEventTypesDtoMap.containsKey(eventSequenceCountDto.getSourceEvent())) {
            adjacentEventTypesDtoMap.get(eventSequenceCountDto.getSourceEvent())
              .getSucceedingEvents()
              .add(eventSequenceCountDto.getTargetEvent());
          } else {
            List<EventTypeDto> targetEvents = new ArrayList<>();
            targetEvents.add(eventSequenceCountDto.getTargetEvent());
            adjacentEventTypesDtoMap.put(
              eventSequenceCountDto.getSourceEvent(),
              AdjacentEventTypesDto.builder().succeedingEvents(targetEvents).build()
            );
          }
          if (adjacentEventTypesDtoMap.containsKey(eventSequenceCountDto.getTargetEvent())) {
            adjacentEventTypesDtoMap.get(eventSequenceCountDto.getTargetEvent())
              .getPrecedingEvents()
              .add(eventSequenceCountDto.getSourceEvent());
          } else {
            List<EventTypeDto> sourceEvents = new ArrayList<>();
            sourceEvents.add(eventSequenceCountDto.getSourceEvent());
            adjacentEventTypesDtoMap.put(
              eventSequenceCountDto.getTargetEvent(),
              AdjacentEventTypesDto.builder().precedingEvents(sourceEvents).build()
            );
          }
        }
      });

    List<EventTypeDto> startEvents = adjacentEventTypesDtoMap.entrySet()
      .stream()
      .filter(startNodeCandidate -> startNodeCandidate.getValue().getPrecedingEvents().isEmpty())
      .map(Map.Entry::getKey)
      .collect(Collectors.toList());
    List<EventTypeDto> endEvents = adjacentEventTypesDtoMap.entrySet()
      .stream()
      .filter(endNodeCandidate -> endNodeCandidate.getValue().getSucceedingEvents().isEmpty())
      .map(Map.Entry::getKey)
      .collect(Collectors.toList());

    final List<EventTraceStateDto> completedTraceSample = getRandomTraceSamplesContainingEventFromEach(
      startEvents,
      endEvents
    );
    return AutogeneratedEventGraphDto.builder()
      .startEvents(startEvents)
      .endEvents(endEvents)
      .adjacentEventTypesDtoMap(adjacentEventTypesDtoMap)
      .sampleAsTypeLists(getTracesAsTypeLists(completedTraceSample))
      .build();
  }

  private List<EventTraceStateDto> getRandomTraceSamplesContainingEventFromEach(final List<EventTypeDto> startEvents,
                                                                                final List<EventTypeDto> endEvents) {
    return eventTraceStateService.getTracesContainingAtLeastOneEventFromEach(
      startEvents,
      endEvents,
      MAX_SAMPLE_RESULTS
    );
  }

  private List<List<EventTypeDto>> getTracesAsTypeLists(final List<EventTraceStateDto> eventTraces) {
    return eventTraces
      .stream()
      .map(trace -> trace.getEventTrace().stream()
        .map(event -> EventTypeDto.builder()
          .group(event.getGroup())
          .source(event.getSource())
          .eventName(event.getEventName())
          .build()
        )
        .collect(Collectors.toList()))
      .collect(Collectors.toList());
  }

}
