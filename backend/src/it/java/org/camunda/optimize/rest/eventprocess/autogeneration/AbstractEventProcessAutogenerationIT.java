/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a commercial license.
 * You may not use this file except in compliance with the commercial license.
 */
package org.camunda.optimize.rest.eventprocess.autogeneration;

import org.assertj.core.groups.Tuple;
import org.camunda.bpm.model.bpmn.BpmnModelInstance;
import org.camunda.bpm.model.bpmn.instance.EndEvent;
import org.camunda.bpm.model.bpmn.instance.ExclusiveGateway;
import org.camunda.bpm.model.bpmn.instance.FlowNode;
import org.camunda.bpm.model.bpmn.instance.Gateway;
import org.camunda.bpm.model.bpmn.instance.InclusiveGateway;
import org.camunda.bpm.model.bpmn.instance.IntermediateCatchEvent;
import org.camunda.bpm.model.bpmn.instance.ParallelGateway;
import org.camunda.bpm.model.bpmn.instance.SequenceFlow;
import org.camunda.bpm.model.bpmn.instance.StartEvent;
import org.camunda.bpm.model.xml.instance.ModelElementInstance;
import org.camunda.optimize.dto.engine.definition.ProcessDefinitionEngineDto;
import org.camunda.optimize.dto.optimize.query.IdDto;
import org.camunda.optimize.dto.optimize.query.event.EventMappingDto;
import org.camunda.optimize.dto.optimize.query.event.EventProcessState;
import org.camunda.optimize.dto.optimize.query.event.EventScopeType;
import org.camunda.optimize.dto.optimize.query.event.EventSourceEntryDto;
import org.camunda.optimize.dto.optimize.query.event.EventTypeDto;
import org.camunda.optimize.dto.optimize.rest.EventProcessMappingCreateRequestDto;
import org.camunda.optimize.dto.optimize.rest.event.EventProcessMappingResponseDto;
import org.camunda.optimize.dto.optimize.rest.event.EventSourceEntryResponseDto;
import org.camunda.optimize.service.EventProcessService;
import org.camunda.optimize.service.importing.eventprocess.AbstractEventProcessIT;
import org.camunda.optimize.test.optimize.EventProcessClient;

import javax.ws.rs.core.Response;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.camunda.optimize.service.util.EventModelBuilderUtil.generateNodeId;

public abstract class AbstractEventProcessAutogenerationIT extends AbstractEventProcessIT {

  protected static final Class<StartEvent> START_EVENT = StartEvent.class;
  protected static final Class<IntermediateCatchEvent> INTERMEDIATE_EVENT = IntermediateCatchEvent.class;
  protected static final Class<EndEvent> END_EVENT = EndEvent.class;
  protected static final Class<ExclusiveGateway> EXCLUSIVE_GATEWAY = ExclusiveGateway.class;
  protected static final Class<ParallelGateway> PARALLEL_GATEWAY = ParallelGateway.class;
  protected static final Class<InclusiveGateway> INCLUSIVE_GATEWAY = InclusiveGateway.class;

  protected void assertProcessMappingConfiguration(final EventProcessMappingResponseDto eventProcessMapping,
                                                   final List<EventSourceEntryDto> externalSources,
                                                   final EventProcessState processState) {
    assertThat(eventProcessMapping.getName()).isEqualTo(EventProcessService.DEFAULT_AUTOGENERATED_PROCESS_NAME);
    assertThat(eventProcessMapping.getState()).isEqualTo(processState);
    assertThat(eventProcessMapping.getEventSources()).extracting(
      EventSourceEntryResponseDto::getEventScope,
      EventSourceEntryResponseDto::getType
    ).containsExactlyInAnyOrderElementsOf(
      externalSources.stream()
        .map(source -> Tuple.tuple(source.getEventScope(), source.getType()))
        .collect(Collectors.toList()));
  }

  protected EventProcessMappingResponseDto autogenerateProcessAndGetMappingResponse(final EventProcessMappingCreateRequestDto createRequestDto) {
    String processId = eventProcessClient.createCreateEventProcessMappingRequest(createRequestDto)
      .execute(IdDto.class, Response.Status.OK.getStatusCode()).getId();
    return eventProcessClient.getEventProcessMapping(processId);
  }

  protected EventProcessMappingCreateRequestDto buildAutogenerateCreateRequestDto(final List<EventSourceEntryDto> sources) {
    return EventProcessMappingCreateRequestDto.eventProcessMappingCreateBuilder()
      .eventSources(sources)
      .autogenerate(true)
      .build();
  }

  protected EventSourceEntryDto deployDefinitionAndCreateEventSource(final BpmnModelInstance modelInstance,
                                                                     final EventScopeType eventScopeType) {
    final ProcessDefinitionEngineDto processDefinitionEngineDto =
      engineIntegrationExtension.deployProcessAndGetProcessDefinition(
      modelInstance);
    importEngineEntities();
    return createCamundaSourceEntry(processDefinitionEngineDto.getKey(), eventScopeType);
  }

  protected EventSourceEntryDto createCamundaSourceEntry(final String definitionKey,
                                                         final EventScopeType eventScopeType) {
    return EventProcessClient.createSimpleCamundaEventSourceEntry(
      definitionKey)
      .toBuilder()
      .eventScope(Collections.singletonList(eventScopeType))
      .build();
  }

  protected void assertNodeConnection(final String firstNodeId,
                                      final Class<? extends FlowNode> expectedNodeType,
                                      final String expectedConnectedNodeId,
                                      final Class<? extends FlowNode> expectedConnectedNodeType,
                                      final BpmnModelInstance modelInstance) {
    final ModelElementInstance element = modelInstance.getModelElementById(firstNodeId);
    assertThat(expectedNodeType.isAssignableFrom(element.getElementType().getInstanceType())).isTrue();
    final Collection<SequenceFlow> outgoingSequenceFlows = expectedNodeType.cast(element).getOutgoing();
    if (expectedConnectedNodeId == null) {
      // We expect no outgoing sequence flows for end events
      assertThat(outgoingSequenceFlows).isEmpty();
    } else {
      final Optional<FlowNode> connectedNode = outgoingSequenceFlows.stream()
        .map(SequenceFlow::getTarget)
        .filter(targetNodes -> targetNodes.getId().equals(expectedConnectedNodeId))
        .findFirst();
      assertThat(connectedNode).isPresent();
      assertThat(expectedConnectedNodeType.isAssignableFrom(connectedNode.get().getElementType().getInstanceType()))
        .isTrue();
    }
  }

  protected void assertCorrectMappingsAndContainsEvents(final Map<String, EventMappingDto> mappings,
                                                        final BpmnModelInstance bpmnModelInstance,
                                                        final List<EventTypeDto> expectedMappedEvents) {
    assertThat(mappings)
      .hasSize(expectedMappedEvents.size())
      .satisfies(modeledMappings -> assertThat(modeledMappings.values())
        .extracting(EventMappingDto::getStart)
        .containsExactlyInAnyOrderElementsOf(expectedMappedEvents))
      .allSatisfy((id, mapping) -> assertThat(bpmnModelInstance.getModelElementById(id).getElementType()).isNotNull());
  }

  protected void assertGatewayWithSourcesAndTargets(final List<String> expectedSourceNodeIds,
                                                    final List<String> expectedTargetNodeIds,
                                                    final Gateway gateway) {
    final List<String> incomingNodeIds = gateway.getIncoming()
      .stream()
      .map(SequenceFlow::getSource)
      .map(FlowNode::getId)
      .collect(Collectors.toList());
    final List<String> outgoingNodeIds = gateway.getOutgoing()
      .stream()
      .map(SequenceFlow::getTarget)
      .map(FlowNode::getId)
      .collect(Collectors.toList());
    assertThat(incomingNodeIds).containsExactlyInAnyOrderElementsOf(expectedSourceNodeIds);
    assertThat(outgoingNodeIds).containsExactlyInAnyOrderElementsOf(expectedTargetNodeIds);
  }

  protected Gateway getGatewayWithId(final Collection<Gateway> gateways, final String gatewayId) {
    return gateways.stream()
      .filter(gateway -> gateway.getId().equals(gatewayId))
      .findFirst()
      .get();
  }

  protected void processEventCountAndTraces() {
    elasticSearchIntegrationTestExtension.refreshAllOptimizeIndices();
    embeddedOptimizeExtension.processEvents();
    elasticSearchIntegrationTestExtension.refreshAllOptimizeIndices();
  }

  protected String idOf(EventTypeDto eventTypeDto) {
    return generateNodeId(eventTypeDto);
  }

}
