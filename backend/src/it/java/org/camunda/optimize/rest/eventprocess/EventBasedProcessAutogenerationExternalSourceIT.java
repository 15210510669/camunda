/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a commercial license.
 * You may not use this file except in compliance with the commercial license.
 */
package org.camunda.optimize.rest.eventprocess;

import org.assertj.core.groups.Tuple;
import org.camunda.bpm.model.bpmn.BpmnModelInstance;
import org.camunda.bpm.model.bpmn.GatewayDirection;
import org.camunda.bpm.model.bpmn.instance.EndEvent;
import org.camunda.bpm.model.bpmn.instance.FlowNode;
import org.camunda.bpm.model.bpmn.instance.Gateway;
import org.camunda.bpm.model.bpmn.instance.IntermediateCatchEvent;
import org.camunda.bpm.model.bpmn.instance.SequenceFlow;
import org.camunda.bpm.model.bpmn.instance.StartEvent;
import org.camunda.bpm.model.xml.instance.ModelElementInstance;
import org.camunda.optimize.dto.optimize.query.event.EventMappingDto;
import org.camunda.optimize.dto.optimize.query.event.EventProcessState;
import org.camunda.optimize.dto.optimize.query.event.EventSourceEntryDto;
import org.camunda.optimize.dto.optimize.query.event.EventTypeDto;
import org.camunda.optimize.dto.optimize.rest.CloudEventDto;
import org.camunda.optimize.dto.optimize.rest.EventProcessMappingCreateRequestDto;
import org.camunda.optimize.dto.optimize.rest.event.EventProcessMappingResponseDto;
import org.camunda.optimize.dto.optimize.rest.event.EventSourceEntryResponseDto;
import org.camunda.optimize.service.AutogeneratedProcessModelService;
import org.camunda.optimize.service.EventProcessService;
import org.camunda.optimize.service.util.BpmnModelUtility;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.camunda.optimize.test.optimize.EventProcessClient.createExternalEventSourceEntry;
import static org.camunda.optimize.test.optimize.EventProcessClient.createMappedEventDto;

public class EventBasedProcessAutogenerationExternalSourceIT extends AbstractEventProcessAutogenerationIT {

  private static final EventTypeDto EVENT_A = createMappedEventDto();
  private static final EventTypeDto EVENT_B = createMappedEventDto();
  private static final EventTypeDto EVENT_C = createMappedEventDto();
  private static final EventTypeDto EVENT_D = createMappedEventDto();

  @BeforeEach
  public void init() {
    embeddedOptimizeExtension.getConfigurationService()
      .getEventBasedProcessConfiguration()
      .getEventImport()
      .setEnabled(true);
  }

  @Test
  public void createFromExternalSource_simpleLinearModel() {
    // given
    final String traceId = "tracingId";
    final Instant now = Instant.now();
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, traceId, now),
      createCloudEventOfType(EVENT_B, traceId, now.plusSeconds(10)),
      createCloudEventOfType(EVENT_C, traceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, traceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    assertThat(modelInstance.getModelElementsByType(FlowNode.class).size()).isEqualTo(mappings.size());

    // then the model elements are of the correct type and connected to sequence flows correctly
    assertEventIsOfTypeAndConnectedTo(EVENT_A, StartEvent.class, EVENT_B, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_B, IntermediateCatchEvent.class, EVENT_C, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_C, IntermediateCatchEvent.class, EVENT_D, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_D, EndEvent.class, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(3);
  }

  @Test
  public void createFromExternalSource_twoStartEvents() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_C, firstTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, firstTraceId, now.plusSeconds(30))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_B, secondTraceId, now),
      createCloudEventOfType(EVENT_C, secondTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, secondTraceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    assertThat(modelInstance.getModelElementsByType(FlowNode.class).size()).isEqualTo(mappings.size());

    // then the model elements are of the correct type and connected to sequence flows correctly
    assertEventIsOfTypeAndConnectedTo(EVENT_A, StartEvent.class, EVENT_C, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_B, StartEvent.class, EVENT_C, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_C, IntermediateCatchEvent.class, EVENT_D, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_D, EndEvent.class, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(3);
  }

  @Test
  public void createFromExternalSource_twoEndEvents() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_C, firstTraceId, now.plusSeconds(30))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, secondTraceId, now),
      createCloudEventOfType(EVENT_B, secondTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, secondTraceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    // The extra flow node is the added gateway
    assertThat(modelInstance.getModelElementsByType(FlowNode.class).size()).isEqualTo(mappings.size() + 1);

    // then the model elements are of the correct type and connected to sequence flows correctly
    assertEventIsOfTypeAndConnectedTo(EVENT_A, StartEvent.class, EVENT_B, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_B, IntermediateCatchEvent.class, null, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_C, EndEvent.class, null, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_D, EndEvent.class, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(4);

    // then the correct gateways exist in model
    final Collection<Gateway> gatewaysInModel = modelInstance.getModelElementsByType(Gateway.class);
    assertThat(gatewaysInModel).hasSize(1);
    assertGatewayWithSourcesAndTargets(
      Arrays.asList(getIdForEventType(EVENT_B)),
      Arrays.asList(getIdForEventType(EVENT_C), getIdForEventType(EVENT_D)),
      GatewayDirection.Diverging,
      gatewaysInModel
    );
  }

  @Test
  public void createFromExternalSource_twoIntermediateEventsSplitWithGateway() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, firstTraceId, now.plusSeconds(30))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, secondTraceId, now),
      createCloudEventOfType(EVENT_C, secondTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, secondTraceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    // The extra flow node is the added gateway
    assertThat(modelInstance.getModelElementsByType(FlowNode.class).size()).isEqualTo(mappings.size() + 1);

    // then the model elements are of the correct type and connected to sequence flows correctly
    assertEventIsOfTypeAndConnectedTo(EVENT_A, StartEvent.class, null, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_B, IntermediateCatchEvent.class, EVENT_D, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_C, IntermediateCatchEvent.class, EVENT_D, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_D, EndEvent.class, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(5);

    // then the correct gateways exist in model
    final Collection<Gateway> gatewaysInModel = modelInstance.getModelElementsByType(Gateway.class);
    assertThat(gatewaysInModel).hasSize(1);
    assertGatewayWithSourcesAndTargets(
      Arrays.asList(getIdForEventType(EVENT_A)),
      Arrays.asList(getIdForEventType(EVENT_B), getIdForEventType(EVENT_C)),
      GatewayDirection.Diverging,
      gatewaysInModel
    );
  }

  @Test
  public void createFromExternalSource_twoUnconnectedPaths() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_C, secondTraceId, now),
      createCloudEventOfType(EVENT_D, secondTraceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    assertThat(modelInstance.getModelElementsByType(FlowNode.class).size()).isEqualTo(mappings.size());

    // then the model elements are of the correct type and connected to sequence flows correctly
    assertEventIsOfTypeAndConnectedTo(EVENT_A, StartEvent.class, EVENT_B, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_B, EndEvent.class, null, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_C, StartEvent.class, EVENT_D, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_D, EndEvent.class, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(2);
  }

  @Test
  public void createFromExternalSource_noEligibleStartEvents() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_B, secondTraceId, now),
      createCloudEventOfType(EVENT_A, secondTraceId, now.plusSeconds(20))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then no xml and mappings are generated
    assertUnmappedSavedEventBasedProcess(processMapping, externalSource);
  }

  @Test
  public void createFromExternalSource_noEligibleEndEvents() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_B, secondTraceId, now),
      createCloudEventOfType(EVENT_A, secondTraceId, now.plusSeconds(20))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then no xml and mappings are generated
    assertUnmappedSavedEventBasedProcess(processMapping, externalSource);
  }

  @Test
  public void createFromExternalSource_singleEventForAllTraces() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Collections.singletonList(createCloudEventOfType(EVENT_A, firstTraceId, now)));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Collections.singletonList(EVENT_A));
    assertThat(modelInstance.getModelElementsByType(FlowNode.class).size()).isEqualTo(mappings.size());

    // then the model elements are of the correct type
    assertEventIsOfTypeAndConnectedTo(EVENT_A, StartEvent.class, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).isEmpty();
  }

  @Test
  public void createFromExternalSource_modelContainingLoop() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(10)),
      createCloudEventOfType(EVENT_C, firstTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, firstTraceId, now.plusSeconds(30))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_C, secondTraceId, now),
      createCloudEventOfType(EVENT_B, secondTraceId, now.plusSeconds(10))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    // The extra flow node is the added gateway
    assertThat(modelInstance.getModelElementsByType(FlowNode.class).size()).isEqualTo(mappings.size() + 1);

    // then the model elements are of the correct type and connected to sequence flows correctly
    assertEventIsOfTypeAndConnectedTo(EVENT_A, StartEvent.class, EVENT_B, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_B, IntermediateCatchEvent.class, EVENT_C, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_C, IntermediateCatchEvent.class, null, modelInstance);
    assertEventIsOfTypeAndConnectedTo(EVENT_D, EndEvent.class, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(5);

    // then the correct gateways exist in model
    final Collection<Gateway> gatewaysInModel = modelInstance.getModelElementsByType(Gateway.class);
    assertThat(gatewaysInModel).hasSize(1);
    assertGatewayWithSourcesAndTargets(
      Arrays.asList(getIdForEventType(EVENT_C)),
      Arrays.asList(getIdForEventType(EVENT_B), getIdForEventType(EVENT_D)),
      GatewayDirection.Diverging,
      gatewaysInModel
    );
  }

  private void assertGatewayWithSourcesAndTargets(final List<String> expectedSourceEventIds,
                                                  final List<String> expectedTargetEventsEventIds,
                                                  final GatewayDirection expectedDirection,
                                                  final Collection<Gateway> gatewaysInModel) {
    assertThat(gatewaysInModel).hasSize(1);
    final Gateway gateway = gatewaysInModel.iterator().next();
    assertThat(gateway.getGatewayDirection()).isEqualTo(expectedDirection);
    final List<String> incomingNodeIds = gateway.getIncoming()
      .stream()
      .map(SequenceFlow::getSource)
      .map(FlowNode::getId)
      .collect(Collectors.toList());
    final List<String> outgoingNodeIds = gateway.getOutgoing()
      .stream()
      .map(SequenceFlow::getTarget)
      .map(FlowNode::getId)
      .collect(Collectors.toList());
    assertThat(incomingNodeIds).containsExactlyInAnyOrderElementsOf(expectedSourceEventIds);
    assertThat(outgoingNodeIds).containsExactlyInAnyOrderElementsOf(expectedTargetEventsEventIds);
  }

  private void assertEventIsOfTypeAndConnectedTo(final EventTypeDto firstEvent,
                                                 final Class<? extends FlowNode> eventAType,
                                                 final EventTypeDto secondEvent,
                                                 final BpmnModelInstance modelInstance) {
    final String firstEventElementId = getIdForEventType(firstEvent);
    final ModelElementInstance element = modelInstance.getModelElementById(firstEventElementId);
    assertThat(eventAType.isAssignableFrom(element.getElementType().getInstanceType())).isTrue();
    final Collection<SequenceFlow> outgoingFlows = eventAType.cast(element).getOutgoing();
    if (secondEvent != null) {
      assertThat(outgoingFlows).hasSize(1);
      final FlowNode targetNode = outgoingFlows.iterator().next().getTarget();
      assertThat(targetNode.getId()).isEqualTo(getIdForEventType(secondEvent));
    }
  }

  private String getIdForEventType(EventTypeDto eventTypeDto) {
    return AutogeneratedProcessModelService.generateNodeId(eventTypeDto);
  }

  private CloudEventDto createCloudEventOfType(final EventTypeDto eventType,
                                               final String traceId,
                                               final Instant now) {
    return eventClient.createCloudEventDto().toBuilder()
      .group(eventType.getGroup())
      .source(eventType.getSource())
      .type(eventType.getEventName())
      .traceid(traceId)
      .time(now).build();
  }

  private void assertCorrectMappingsAndContainsEvents(final Map<String, EventMappingDto> mappings,
                                                      final BpmnModelInstance bpmnModelInstance,
                                                      final List<EventTypeDto> expectedMappedEvents) {
    assertThat(mappings)
      .hasSize(expectedMappedEvents.size())
      .satisfies(modeledMappings -> assertThat(modeledMappings.values())
        .extracting(EventMappingDto::getStart)
        .containsExactlyInAnyOrderElementsOf(expectedMappedEvents))
      .allSatisfy((id, mapping) -> assertThat(bpmnModelInstance.getModelElementById(id).getElementType()).isNotNull());
  }

  private void assertProcessMappingConfiguration(final EventProcessMappingResponseDto eventProcessMapping,
                                                 final List<EventSourceEntryDto> externalSources) {
    assertThat(eventProcessMapping.getName()).isEqualTo(EventProcessService.DEFAULT_AUTOGENERATED_PROCESS_NAME);
    assertThat(eventProcessMapping.getState()).isEqualTo(EventProcessState.MAPPED);
    assertThat(eventProcessMapping.getEventSources()).extracting(
      EventSourceEntryResponseDto::getEventScope,
      EventSourceEntryResponseDto::getType
    ).containsExactlyInAnyOrderElementsOf(
      externalSources.stream()
        .map(source -> Tuple.tuple(source.getEventScope(), source.getType()))
        .collect(Collectors.toList()));
  }

  private void ingestEventAndProcessTraces(List<CloudEventDto> eventsToIngest) {
    eventClient.ingestEventBatch(eventsToIngest);
    processEventCountAndTraces();
  }

}
