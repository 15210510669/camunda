/*
 * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH
 * under one or more contributor license agreements. Licensed under a commercial license.
 * You may not use this file except in compliance with the commercial license.
 */
package org.camunda.optimize.rest.eventprocess;

import org.assertj.core.groups.Tuple;
import org.camunda.bpm.model.bpmn.BpmnModelInstance;
import org.camunda.bpm.model.bpmn.instance.EndEvent;
import org.camunda.bpm.model.bpmn.instance.FlowNode;
import org.camunda.bpm.model.bpmn.instance.Gateway;
import org.camunda.bpm.model.bpmn.instance.IntermediateCatchEvent;
import org.camunda.bpm.model.bpmn.instance.SequenceFlow;
import org.camunda.bpm.model.bpmn.instance.StartEvent;
import org.camunda.bpm.model.xml.instance.ModelElementInstance;
import org.camunda.optimize.dto.optimize.query.event.EventMappingDto;
import org.camunda.optimize.dto.optimize.query.event.EventProcessState;
import org.camunda.optimize.dto.optimize.query.event.EventSourceEntryDto;
import org.camunda.optimize.dto.optimize.query.event.EventTypeDto;
import org.camunda.optimize.dto.optimize.rest.CloudEventDto;
import org.camunda.optimize.dto.optimize.rest.EventProcessMappingCreateRequestDto;
import org.camunda.optimize.dto.optimize.rest.event.EventProcessMappingResponseDto;
import org.camunda.optimize.dto.optimize.rest.event.EventSourceEntryResponseDto;
import org.camunda.optimize.service.AutogeneratedProcessModelService;
import org.camunda.optimize.service.EventProcessService;
import org.camunda.optimize.service.util.BpmnModelUtility;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.camunda.bpm.model.bpmn.GatewayDirection.Converging;
import static org.camunda.bpm.model.bpmn.GatewayDirection.Diverging;
import static org.camunda.optimize.service.AutogeneratedProcessModelService.generateGatewayIdForNode;
import static org.camunda.optimize.test.optimize.EventProcessClient.createExternalEventSourceEntry;
import static org.camunda.optimize.test.optimize.EventProcessClient.createMappedEventDto;

public class EventBasedProcessAutogenerationExternalSourceIT extends AbstractEventProcessAutogenerationIT {

  private static final Class<StartEvent> START_EVENT = StartEvent.class;
  private static final Class<IntermediateCatchEvent> INTERMEDIATE_EVENT = IntermediateCatchEvent.class;
  private static final Class<EndEvent> END_EVENT = EndEvent.class;
  private static final Class<Gateway> GATEWAY = Gateway.class;

  private static final EventTypeDto EVENT_A = createMappedEventDto();
  private static final EventTypeDto EVENT_B = createMappedEventDto();
  private static final EventTypeDto EVENT_C = createMappedEventDto();
  private static final EventTypeDto EVENT_D = createMappedEventDto();

  @BeforeEach
  public void init() {
    embeddedOptimizeExtension.getConfigurationService()
      .getEventBasedProcessConfiguration()
      .getEventImport()
      .setEnabled(true);
  }

  @Test
  public void createFromExternalSource_simpleLinearModel() {
    // given
    final String traceId = "tracingId";
    final Instant now = Instant.now();
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, traceId, now),
      createCloudEventOfType(EVENT_B, traceId, now.plusSeconds(10)),
      createCloudEventOfType(EVENT_C, traceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, traceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    assertThat(modelInstance.getModelElementsByType(FlowNode.class)).hasSize(mappings.size());

    // then the model elements are of the correct type and connected to expected nodes correctly
    assertNodeConnection(idOf(EVENT_A), START_EVENT, idOf(EVENT_B), INTERMEDIATE_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_B), INTERMEDIATE_EVENT, idOf(EVENT_C), INTERMEDIATE_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_C), INTERMEDIATE_EVENT, idOf(EVENT_D), END_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_D), END_EVENT, null, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(3);
  }

  @Test
  public void createFromExternalSource_twoStartEvents() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_C, firstTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, firstTraceId, now.plusSeconds(30))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_B, secondTraceId, now),
      createCloudEventOfType(EVENT_C, secondTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, secondTraceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    // The extra flow node is the added gateway
    assertThat(modelInstance.getModelElementsByType(FlowNode.class)).hasSize(mappings.size() + 1);

    // then the model elements are of the correct type and connected to expected nodes correctly
    final String expectedGatewayId = generateGatewayIdForNode(EVENT_C, Converging);
    assertNodeConnection(idOf(EVENT_A), START_EVENT, expectedGatewayId, GATEWAY, modelInstance);
    assertNodeConnection(idOf(EVENT_B), START_EVENT, expectedGatewayId, GATEWAY, modelInstance);
    assertNodeConnection(expectedGatewayId, GATEWAY, idOf(EVENT_C), INTERMEDIATE_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_C), INTERMEDIATE_EVENT, idOf(EVENT_D), END_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_D), END_EVENT, null, null, modelInstance);

    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(4);

    // and the gateways have the expected source and target events
    final Collection<Gateway> gatewaysInModel = modelInstance.getModelElementsByType(GATEWAY);
    assertThat(gatewaysInModel).hasSize(1);
    assertGatewayWithSourcesAndTargets(
      Arrays.asList(idOf(EVENT_A), idOf(EVENT_B)),
      Arrays.asList(idOf(EVENT_C)),
      getGatewayWithId(gatewaysInModel, expectedGatewayId)
    );
  }

  @Test
  public void createFromExternalSource_twoEndEvents() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_C, firstTraceId, now.plusSeconds(30))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, secondTraceId, now),
      createCloudEventOfType(EVENT_B, secondTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, secondTraceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    // The extra flow node is the added gateway
    assertThat(modelInstance.getModelElementsByType(FlowNode.class)).hasSize(mappings.size() + 1);

    // then the model elements are of the correct type and connected to sequence flows correctly
    final String expectedGatewayId = generateGatewayIdForNode(EVENT_B, Diverging);
    assertNodeConnection(idOf(EVENT_A), START_EVENT, idOf(EVENT_B), INTERMEDIATE_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_B), INTERMEDIATE_EVENT, expectedGatewayId, GATEWAY, modelInstance);
    assertNodeConnection(expectedGatewayId, GATEWAY, idOf(EVENT_C), END_EVENT, modelInstance);
    assertNodeConnection(expectedGatewayId, GATEWAY, idOf(EVENT_D), END_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_D), END_EVENT, null, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(4);

    // and the gateways have the expected source and target events
    final Collection<Gateway> gatewaysInModel = modelInstance.getModelElementsByType(Gateway.class);
    assertThat(gatewaysInModel).hasSize(1);
    assertGatewayWithSourcesAndTargets(
      Arrays.asList(idOf(EVENT_B)),
      Arrays.asList(idOf(EVENT_C), idOf(EVENT_D)),
      getGatewayWithId(gatewaysInModel, generateGatewayIdForNode(EVENT_B, Diverging))
    );
  }

  @Test
  public void createFromExternalSource_twoIntermediateEventsSplitWithGateway() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, firstTraceId, now.plusSeconds(30))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, secondTraceId, now),
      createCloudEventOfType(EVENT_C, secondTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, secondTraceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    // The extra flow nodes are the added gateways
    assertThat(modelInstance.getModelElementsByType(FlowNode.class)).hasSize(mappings.size() + 2);

    // then the model elements are of the correct type and connected to sequence flows correctly
    final String divergingGatewayId = generateGatewayIdForNode(EVENT_A, Diverging);
    final String convergingGatewayId = generateGatewayIdForNode(EVENT_D, Converging);
    assertNodeConnection(idOf(EVENT_A), START_EVENT, divergingGatewayId, GATEWAY, modelInstance);
    assertNodeConnection(divergingGatewayId, GATEWAY, idOf(EVENT_B), INTERMEDIATE_EVENT, modelInstance);
    assertNodeConnection(divergingGatewayId, GATEWAY, idOf(EVENT_C), INTERMEDIATE_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_B), INTERMEDIATE_EVENT, convergingGatewayId, GATEWAY, modelInstance);
    assertNodeConnection(idOf(EVENT_C), INTERMEDIATE_EVENT, convergingGatewayId, GATEWAY, modelInstance);
    assertNodeConnection(convergingGatewayId, GATEWAY, idOf(EVENT_D), END_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_D), END_EVENT, null, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(6);

    // and the gateways have the expected source and target events
    final Collection<Gateway> gatewaysInModel = modelInstance.getModelElementsByType(Gateway.class);
    assertThat(gatewaysInModel).hasSize(2);
    assertGatewayWithSourcesAndTargets(
      Arrays.asList(idOf(EVENT_A)),
      Arrays.asList(idOf(EVENT_B), idOf(EVENT_C)),
      getGatewayWithId(gatewaysInModel, divergingGatewayId)
    );
    assertGatewayWithSourcesAndTargets(
      Arrays.asList(idOf(EVENT_B), idOf(EVENT_C)),
      Arrays.asList(idOf(EVENT_D)),
      getGatewayWithId(gatewaysInModel, convergingGatewayId)
    );
  }

  @Test
  public void createFromExternalSource_twoUnconnectedPaths() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_C, secondTraceId, now),
      createCloudEventOfType(EVENT_D, secondTraceId, now.plusSeconds(30))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    assertThat(modelInstance.getModelElementsByType(FlowNode.class)).hasSize(mappings.size());

    // then the model elements are of the correct type and connected to sequence flows correctly
    assertNodeConnection(idOf(EVENT_A), START_EVENT, idOf(EVENT_B), END_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_B), END_EVENT, null, null, modelInstance);
    assertNodeConnection(idOf(EVENT_C), START_EVENT, idOf(EVENT_D), END_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_D), END_EVENT, null, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(2);
  }

  @Test
  public void createFromExternalSource_noEligibleStartEvents() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_B, secondTraceId, now),
      createCloudEventOfType(EVENT_A, secondTraceId, now.plusSeconds(20))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then no xml and mappings are generated
    assertUnmappedSavedEventBasedProcess(processMapping, externalSource);
  }

  @Test
  public void createFromExternalSource_noEligibleEndEvents() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(20))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_B, secondTraceId, now),
      createCloudEventOfType(EVENT_A, secondTraceId, now.plusSeconds(20))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then no xml and mappings are generated
    assertUnmappedSavedEventBasedProcess(processMapping, externalSource);
  }

  @Test
  public void createFromExternalSource_singleEventForAllTraces() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Collections.singletonList(createCloudEventOfType(EVENT_A, firstTraceId, now)));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Collections.singletonList(EVENT_A));
    assertThat(modelInstance.getModelElementsByType(FlowNode.class)).hasSize(mappings.size());

    // then the model elements are of the correct type
    assertNodeConnection(idOf(EVENT_A), START_EVENT, null, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).isEmpty();
  }

  @Test
  public void createFromExternalSource_modelContainingLoop() {
    // given
    final Instant now = Instant.now();
    final String firstTraceId = "firstTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_A, firstTraceId, now),
      createCloudEventOfType(EVENT_B, firstTraceId, now.plusSeconds(10)),
      createCloudEventOfType(EVENT_C, firstTraceId, now.plusSeconds(20)),
      createCloudEventOfType(EVENT_D, firstTraceId, now.plusSeconds(30))
    ));
    final String secondTraceId = "secondTraceTraceId";
    ingestEventAndProcessTraces(Arrays.asList(
      createCloudEventOfType(EVENT_C, secondTraceId, now),
      createCloudEventOfType(EVENT_B, secondTraceId, now.plusSeconds(10))
    ));
    final List<EventSourceEntryDto> externalSource = Collections.singletonList(createExternalEventSourceEntry());
    final EventProcessMappingCreateRequestDto createRequestDto = buildAutogenerateCreateRequestDto(externalSource);

    // when
    final EventProcessMappingResponseDto processMapping = autogenerateProcessAndGetMappingResponse(createRequestDto);

    // then the created process is configured correctly
    final Map<String, EventMappingDto> mappings = processMapping.getMappings();
    final BpmnModelInstance modelInstance = BpmnModelUtility.parseBpmnModel(processMapping.getXml());
    assertProcessMappingConfiguration(processMapping, externalSource);

    // then the mappings contain the correct events and are all in the model
    assertCorrectMappingsAndContainsEvents(mappings, modelInstance, Arrays.asList(EVENT_A, EVENT_B, EVENT_C, EVENT_D));
    // The extra flow nodes are the added gateways
    assertThat(modelInstance.getModelElementsByType(FlowNode.class)).hasSize(mappings.size() + 2);

    // then the model elements are of the correct type and connected to sequence flows correctly
    final String divergingGatewayId = generateGatewayIdForNode(EVENT_C, Diverging);
    final String convergingGatewayId = generateGatewayIdForNode(EVENT_B, Converging);
    assertNodeConnection(idOf(EVENT_A), START_EVENT, convergingGatewayId, GATEWAY, modelInstance);
    assertNodeConnection(convergingGatewayId, GATEWAY, idOf(EVENT_B), INTERMEDIATE_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_B), INTERMEDIATE_EVENT, idOf(EVENT_C), INTERMEDIATE_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_C), INTERMEDIATE_EVENT, divergingGatewayId, GATEWAY, modelInstance);
    assertNodeConnection(divergingGatewayId, GATEWAY, convergingGatewayId, GATEWAY, modelInstance);
    assertNodeConnection(divergingGatewayId, GATEWAY, idOf(EVENT_D), END_EVENT, modelInstance);
    assertNodeConnection(idOf(EVENT_D), END_EVENT, null, null, modelInstance);
    // and the expected number of sequence flows exists
    assertThat(modelInstance.getModelElementsByType(SequenceFlow.class)).hasSize(6);

    // and the gateways have the expected source and target events
    final Collection<Gateway> gateways = modelInstance.getModelElementsByType(Gateway.class);
    assertThat(gateways).hasSize(2);
    assertGatewayWithSourcesAndTargets(
      Arrays.asList(idOf(EVENT_A), divergingGatewayId),
      Arrays.asList(idOf(EVENT_B)),
      getGatewayWithId(gateways, convergingGatewayId)
    );
    assertGatewayWithSourcesAndTargets(
      Arrays.asList(idOf(EVENT_C)),
      Arrays.asList(convergingGatewayId, idOf(EVENT_D)),
      getGatewayWithId(gateways, divergingGatewayId)
    );
  }

  private Gateway getGatewayWithId(final Collection<Gateway> gateways, final String gatewayId) {
    return gateways.stream()
      .filter(gateway -> gateway.getId().equals(gatewayId))
      .findFirst()
      .get();
  }

  private void assertGatewayWithSourcesAndTargets(final List<String> expectedSourceNodeIds,
                                                  final List<String> expectedTargetNodeIds,
                                                  final Gateway gateway) {
    final List<String> incomingNodeIds = gateway.getIncoming()
      .stream()
      .map(SequenceFlow::getSource)
      .map(FlowNode::getId)
      .collect(Collectors.toList());
    final List<String> outgoingNodeIds = gateway.getOutgoing()
      .stream()
      .map(SequenceFlow::getTarget)
      .map(FlowNode::getId)
      .collect(Collectors.toList());
    assertThat(incomingNodeIds).containsExactlyInAnyOrderElementsOf(expectedSourceNodeIds);
    assertThat(outgoingNodeIds).containsExactlyInAnyOrderElementsOf(expectedTargetNodeIds);
  }

  private void assertNodeConnection(final String firstNodeId,
                                    final Class<? extends FlowNode> expectedNodeType,
                                    final String expectedConnectedNodeId,
                                    final Class<? extends FlowNode> expectedConnectedNodeType,
                                    final BpmnModelInstance modelInstance) {
    final ModelElementInstance element = modelInstance.getModelElementById(firstNodeId);
    assertThat(expectedNodeType.isAssignableFrom(element.getElementType().getInstanceType())).isTrue();
    final Collection<SequenceFlow> outgoingSequenceFlows = expectedNodeType.cast(element).getOutgoing();
    if (expectedConnectedNodeId == null) {
      // We expect no outgoing sequence flows for end events
      assertThat(outgoingSequenceFlows).isEmpty();
    } else {
      final Optional<FlowNode> connectedNode = outgoingSequenceFlows.stream()
        .map(SequenceFlow::getTarget)
        .filter(targetNodes -> targetNodes.getId().equals(expectedConnectedNodeId))
        .findFirst();
      assertThat(connectedNode).isPresent();
      assertThat(expectedConnectedNodeType.isAssignableFrom(connectedNode.get().getElementType().getInstanceType()))
        .isTrue();
    }
  }

  private String idOf(EventTypeDto eventTypeDto) {
    return AutogeneratedProcessModelService.generateNodeId(eventTypeDto);
  }

  private CloudEventDto createCloudEventOfType(final EventTypeDto eventType,
                                               final String traceId,
                                               final Instant now) {
    return eventClient.createCloudEventDto().toBuilder()
      .group(eventType.getGroup())
      .source(eventType.getSource())
      .type(eventType.getEventName())
      .traceid(traceId)
      .time(now).build();
  }

  private void assertCorrectMappingsAndContainsEvents(final Map<String, EventMappingDto> mappings,
                                                      final BpmnModelInstance bpmnModelInstance,
                                                      final List<EventTypeDto> expectedMappedEvents) {
    assertThat(mappings)
      .hasSize(expectedMappedEvents.size())
      .satisfies(modeledMappings -> assertThat(modeledMappings.values())
        .extracting(EventMappingDto::getStart)
        .containsExactlyInAnyOrderElementsOf(expectedMappedEvents))
      .allSatisfy((id, mapping) -> assertThat(bpmnModelInstance.getModelElementById(id).getElementType()).isNotNull());
  }

  private void assertProcessMappingConfiguration(final EventProcessMappingResponseDto eventProcessMapping,
                                                 final List<EventSourceEntryDto> externalSources) {
    assertThat(eventProcessMapping.getName()).isEqualTo(EventProcessService.DEFAULT_AUTOGENERATED_PROCESS_NAME);
    assertThat(eventProcessMapping.getState()).isEqualTo(EventProcessState.MAPPED);
    assertThat(eventProcessMapping.getEventSources()).extracting(
      EventSourceEntryResponseDto::getEventScope,
      EventSourceEntryResponseDto::getType
    ).containsExactlyInAnyOrderElementsOf(
      externalSources.stream()
        .map(source -> Tuple.tuple(source.getEventScope(), source.getType()))
        .collect(Collectors.toList()));
  }

  private void ingestEventAndProcessTraces(List<CloudEventDto> eventsToIngest) {
    eventClient.ingestEventBatch(eventsToIngest);
    processEventCountAndTraces();
  }

}
