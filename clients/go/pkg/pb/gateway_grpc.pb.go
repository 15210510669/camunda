// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: gateway.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Gateway_ActivateJobs_FullMethodName                    = "/gateway_protocol.Gateway/ActivateJobs"
	Gateway_StreamActivatedJobs_FullMethodName             = "/gateway_protocol.Gateway/StreamActivatedJobs"
	Gateway_CancelProcessInstance_FullMethodName           = "/gateway_protocol.Gateway/CancelProcessInstance"
	Gateway_CompleteJob_FullMethodName                     = "/gateway_protocol.Gateway/CompleteJob"
	Gateway_CreateProcessInstance_FullMethodName           = "/gateway_protocol.Gateway/CreateProcessInstance"
	Gateway_CreateProcessInstanceWithResult_FullMethodName = "/gateway_protocol.Gateway/CreateProcessInstanceWithResult"
	Gateway_EvaluateDecision_FullMethodName                = "/gateway_protocol.Gateway/EvaluateDecision"
	Gateway_DeployProcess_FullMethodName                   = "/gateway_protocol.Gateway/DeployProcess"
	Gateway_DeployResource_FullMethodName                  = "/gateway_protocol.Gateway/DeployResource"
	Gateway_FailJob_FullMethodName                         = "/gateway_protocol.Gateway/FailJob"
	Gateway_ThrowError_FullMethodName                      = "/gateway_protocol.Gateway/ThrowError"
	Gateway_PublishMessage_FullMethodName                  = "/gateway_protocol.Gateway/PublishMessage"
	Gateway_ResolveIncident_FullMethodName                 = "/gateway_protocol.Gateway/ResolveIncident"
	Gateway_SetVariables_FullMethodName                    = "/gateway_protocol.Gateway/SetVariables"
	Gateway_Topology_FullMethodName                        = "/gateway_protocol.Gateway/Topology"
	Gateway_UpdateJobRetries_FullMethodName                = "/gateway_protocol.Gateway/UpdateJobRetries"
	Gateway_ModifyProcessInstance_FullMethodName           = "/gateway_protocol.Gateway/ModifyProcessInstance"
	Gateway_MigrateProcessInstance_FullMethodName          = "/gateway_protocol.Gateway/MigrateProcessInstance"
	Gateway_UpdateJobTimeout_FullMethodName                = "/gateway_protocol.Gateway/UpdateJobTimeout"
	Gateway_DeleteResource_FullMethodName                  = "/gateway_protocol.Gateway/DeleteResource"
	Gateway_BroadcastSignal_FullMethodName                 = "/gateway_protocol.Gateway/BroadcastSignal"
)

// GatewayClient is the client API for Gateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GatewayClient interface {
	// Iterates through all known partitions round-robin and activates up to the requested
	// maximum and streams them back to the client as they are activated.
	//
	// Errors:
	// INVALID_ARGUMENT:
	// - type is blank (empty string, null)
	// - worker is blank (empty string, null)
	// - timeout less than 1
	// - maxJobsToActivate is less than 1
	ActivateJobs(ctx context.Context, in *ActivateJobsRequest, opts ...grpc.CallOption) (Gateway_ActivateJobsClient, error)
	// Registers client to a job stream that will stream jobs back to the client as
	// they become activatable.
	//
	// Errors:
	// INVALID_ARGUMENT:
	// - type is blank (empty string, null)
	// - timeout less than 1
	StreamActivatedJobs(ctx context.Context, in *StreamActivatedJobsRequest, opts ...grpc.CallOption) (Gateway_StreamActivatedJobsClient, error)
	// Cancels a running process instance
	//
	// Errors:
	// NOT_FOUND:
	// - no process instance exists with the given key
	CancelProcessInstance(ctx context.Context, in *CancelProcessInstanceRequest, opts ...grpc.CallOption) (*CancelProcessInstanceResponse, error)
	// Completes a job with the given variables, which allows completing the associated service task.
	//
	// Errors:
	// NOT_FOUND:
	// - no job exists with the given job key. Note that since jobs are removed once completed,
	// it could be that this job did exist at some point.
	//
	// FAILED_PRECONDITION:
	// - the job was marked as failed. In that case, the related incident must be resolved before
	// the job can be activated again and completed.
	CompleteJob(ctx context.Context, in *CompleteJobRequest, opts ...grpc.CallOption) (*CompleteJobResponse, error)
	// Creates and starts an instance of the specified process. The process definition to use to
	// create the instance can be specified either using its unique key (as returned by
	// DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
	// latest deployed version. Note that only processes with none start events can be started through
	// this command.
	//
	// Errors:
	// NOT_FOUND:
	// - no process with the given key exists (if processDefinitionKey was given)
	// - no process with the given process ID exists (if bpmnProcessId was given but version was -1)
	// - no process with the given process ID and version exists (if both bpmnProcessId and version were given)
	//
	// FAILED_PRECONDITION:
	// - the process definition does not contain a none start event; only processes with none
	// start event can be started manually.
	//
	// INVALID_ARGUMENT:
	// - the given variables argument is not a valid JSON document; it is expected to be a valid
	// JSON document where the root node is an object.
	CreateProcessInstance(ctx context.Context, in *CreateProcessInstanceRequest, opts ...grpc.CallOption) (*CreateProcessInstanceResponse, error)
	// Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
	CreateProcessInstanceWithResult(ctx context.Context, in *CreateProcessInstanceWithResultRequest, opts ...grpc.CallOption) (*CreateProcessInstanceWithResultResponse, error)
	// Evaluates a decision. The decision to evaluate can be specified either by
	// using its unique key (as returned by DeployResource), or using the decision
	// ID. When using the decision ID, the latest deployed version of the decision
	// is used.
	//
	// Errors:
	// INVALID_ARGUMENT:
	// - no decision with the given key exists (if decisionKey was given)
	// - no decision with the given decision ID exists (if decisionId was given)
	// - both decision ID and decision KEY were provided, or are missing
	EvaluateDecision(ctx context.Context, in *EvaluateDecisionRequest, opts ...grpc.CallOption) (*EvaluateDecisionResponse, error)
	// Deprecated: Do not use.
	//
	// Deploys one or more processes to Zeebe. Note that this is an atomic call,
	// i.e. either all processes are deployed, or none of them are.
	//
	// Errors:
	// INVALID_ARGUMENT:
	// - no resources given.
	// - if at least one resource is invalid. A resource is considered invalid if:
	// - the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
	// - the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
	DeployProcess(ctx context.Context, in *DeployProcessRequest, opts ...grpc.CallOption) (*DeployProcessResponse, error)
	// Deploys one or more resources (e.g. processes or decision models) to Zeebe.
	// Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
	//
	// Errors:
	// PERMISSION_DENIED:
	// - if a deployment to an unauthorized tenant is performed
	// INVALID_ARGUMENT:
	// - no resources given.
	// - if at least one resource is invalid. A resource is considered invalid if:
	// - the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
	// - the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
	// - if multi-tenancy is enabled, and:
	// - a tenant id is not provided
	// - a tenant id with an invalid format is provided
	// - if multi-tenancy is disabled and a tenant id is provided
	DeployResource(ctx context.Context, in *DeployResourceRequest, opts ...grpc.CallOption) (*DeployResourceResponse, error)
	// Marks the job as failed; if the retries argument is positive, then the job will be immediately
	// activatable again, and a worker could try again to process it. If it is zero or negative however,
	// an incident will be raised, tagged with the given errorMessage, and the job will not be
	// activatable until the incident is resolved.
	//
	// Errors:
	// NOT_FOUND:
	// - no job was found with the given key
	//
	// FAILED_PRECONDITION:
	// - the job was not activated
	// - the job is already in a failed state, i.e. ran out of retries
	FailJob(ctx context.Context, in *FailJobRequest, opts ...grpc.CallOption) (*FailJobResponse, error)
	// Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
	//
	// Errors:
	// NOT_FOUND:
	// - no job was found with the given key
	//
	// FAILED_PRECONDITION:
	// - the job is not in an activated state
	ThrowError(ctx context.Context, in *ThrowErrorRequest, opts ...grpc.CallOption) (*ThrowErrorResponse, error)
	// Publishes a single message. Messages are published to specific partitions computed from their
	// correlation keys.
	//
	// Errors:
	// ALREADY_EXISTS:
	// - a message with the same ID was previously published (and is still alive)
	PublishMessage(ctx context.Context, in *PublishMessageRequest, opts ...grpc.CallOption) (*PublishMessageResponse, error)
	// Resolves a given incident. This simply marks the incident as resolved; most likely a call to
	// UpdateJobRetries or SetVariables will be necessary to actually resolve the
	// problem, following by this call.
	//
	// Errors:
	// NOT_FOUND:
	// - no incident with the given key exists
	ResolveIncident(ctx context.Context, in *ResolveIncidentRequest, opts ...grpc.CallOption) (*ResolveIncidentResponse, error)
	// Updates all the variables of a particular scope (e.g. process instance, flow element instance)
	// from the given JSON document.
	//
	// Errors:
	// NOT_FOUND:
	// - no element with the given elementInstanceKey exists
	// INVALID_ARGUMENT:
	// - the given variables document is not a valid JSON document; valid documents are expected to
	// be JSON documents where the root node is an object.
	SetVariables(ctx context.Context, in *SetVariablesRequest, opts ...grpc.CallOption) (*SetVariablesResponse, error)
	// Obtains the current topology of the cluster the gateway is part of.
	Topology(ctx context.Context, in *TopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error)
	// Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
	// retries, should the underlying problem be solved.
	//
	// Errors:
	// NOT_FOUND:
	// - no job exists with the given key
	//
	// INVALID_ARGUMENT:
	// - retries is not greater than 0
	UpdateJobRetries(ctx context.Context, in *UpdateJobRetriesRequest, opts ...grpc.CallOption) (*UpdateJobRetriesResponse, error)
	// Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
	//
	// Errors:
	// NOT_FOUND:
	// - no process instance exists with the given key
	//
	// FAILED_PRECONDITION:
	// - trying to activate element inside of a multi-instance
	//
	// INVALID_ARGUMENT:
	// - activating or terminating unknown element
	// - ancestor of element for activation doesn't exist
	// - scope of variable is unknown
	ModifyProcessInstance(ctx context.Context, in *ModifyProcessInstanceRequest, opts ...grpc.CallOption) (*ModifyProcessInstanceResponse, error)
	// Migrates the process instance to the specified process definition.
	// In simple terms, this is handled by updating the active element's process.
	//
	// Errors:
	// NOT_FOUND:
	// - the process instance referenced by `processInstanceKey` is not active
	//
	// FAILED_PRECONDITION:
	// - not all active elements in the source process instance are mapped to the elements in the target process
	// - a mapping instruction changes the type of an element or event
	// - a mapping instruction refers to an unsupported element (i.e. some elements will be supported later on)
	// - a mapping instruction refers to element in unsupported scenarios.
	// (i.e. migrating active elements with event subscriptions will be supported later on)
	//
	// INVALID_ARGUMENT:
	// - the source element id does not refer to an element in the source process definition
	// - a source element id is mapped by multiple mapping instructions.
	// For example, the engine cannot determine how to migrate a process instance when the instructions are: [A->B, A->C].
	MigrateProcessInstance(ctx context.Context, in *MigrateProcessInstanceRequest, opts ...grpc.CallOption) (*MigrateProcessInstanceResponse, error)
	// Updates the deadline of a job using the timeout (in ms) provided. This can be used
	// for extending or shortening the job deadline.
	//
	// Errors:
	// NOT_FOUND:
	// - no job exists with the given key
	//
	// INVALID_STATE:
	// - no deadline exists for the given job key
	UpdateJobTimeout(ctx context.Context, in *UpdateJobTimeoutRequest, opts ...grpc.CallOption) (*UpdateJobTimeoutResponse, error)
	// Deletes a resource from the state. Once a resource has been deleted it cannot
	// be recovered. If the resource needs to be available again, a new deployment
	// of the resource is required.
	//
	// Deleting a process will cancel any running instances of this process
	// definition. New instances of a deleted process are created using
	// the lastest version that hasn't been deleted. Creating a new
	// process instance is impossible when all versions have been
	// deleted.
	//
	// Deleting a decision requirement definitions could cause incidents in process
	// instances referencing these decisions in a business rule task. A decision
	// will be evaluated with the latest version that hasn't been deleted. If all
	// versions of a decision have been deleted the evaluation is rejected.
	//
	// Errors:
	// NOT_FOUND:
	// - No resource exists with the given key
	DeleteResource(ctx context.Context, in *DeleteResourceRequest, opts ...grpc.CallOption) (*DeleteResourceResponse, error)
	// Broadcasts a signal.
	BroadcastSignal(ctx context.Context, in *BroadcastSignalRequest, opts ...grpc.CallOption) (*BroadcastSignalResponse, error)
}

type gatewayClient struct {
	cc grpc.ClientConnInterface
}

func NewGatewayClient(cc grpc.ClientConnInterface) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) ActivateJobs(ctx context.Context, in *ActivateJobsRequest, opts ...grpc.CallOption) (Gateway_ActivateJobsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Gateway_ServiceDesc.Streams[0], Gateway_ActivateJobs_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &gatewayActivateJobsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Gateway_ActivateJobsClient interface {
	Recv() (*ActivateJobsResponse, error)
	grpc.ClientStream
}

type gatewayActivateJobsClient struct {
	grpc.ClientStream
}

func (x *gatewayActivateJobsClient) Recv() (*ActivateJobsResponse, error) {
	m := new(ActivateJobsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gatewayClient) StreamActivatedJobs(ctx context.Context, in *StreamActivatedJobsRequest, opts ...grpc.CallOption) (Gateway_StreamActivatedJobsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Gateway_ServiceDesc.Streams[1], Gateway_StreamActivatedJobs_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &gatewayStreamActivatedJobsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Gateway_StreamActivatedJobsClient interface {
	Recv() (*ActivatedJob, error)
	grpc.ClientStream
}

type gatewayStreamActivatedJobsClient struct {
	grpc.ClientStream
}

func (x *gatewayStreamActivatedJobsClient) Recv() (*ActivatedJob, error) {
	m := new(ActivatedJob)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gatewayClient) CancelProcessInstance(ctx context.Context, in *CancelProcessInstanceRequest, opts ...grpc.CallOption) (*CancelProcessInstanceResponse, error) {
	out := new(CancelProcessInstanceResponse)
	err := c.cc.Invoke(ctx, Gateway_CancelProcessInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) CompleteJob(ctx context.Context, in *CompleteJobRequest, opts ...grpc.CallOption) (*CompleteJobResponse, error) {
	out := new(CompleteJobResponse)
	err := c.cc.Invoke(ctx, Gateway_CompleteJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) CreateProcessInstance(ctx context.Context, in *CreateProcessInstanceRequest, opts ...grpc.CallOption) (*CreateProcessInstanceResponse, error) {
	out := new(CreateProcessInstanceResponse)
	err := c.cc.Invoke(ctx, Gateway_CreateProcessInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) CreateProcessInstanceWithResult(ctx context.Context, in *CreateProcessInstanceWithResultRequest, opts ...grpc.CallOption) (*CreateProcessInstanceWithResultResponse, error) {
	out := new(CreateProcessInstanceWithResultResponse)
	err := c.cc.Invoke(ctx, Gateway_CreateProcessInstanceWithResult_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) EvaluateDecision(ctx context.Context, in *EvaluateDecisionRequest, opts ...grpc.CallOption) (*EvaluateDecisionResponse, error) {
	out := new(EvaluateDecisionResponse)
	err := c.cc.Invoke(ctx, Gateway_EvaluateDecision_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *gatewayClient) DeployProcess(ctx context.Context, in *DeployProcessRequest, opts ...grpc.CallOption) (*DeployProcessResponse, error) {
	out := new(DeployProcessResponse)
	err := c.cc.Invoke(ctx, Gateway_DeployProcess_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) DeployResource(ctx context.Context, in *DeployResourceRequest, opts ...grpc.CallOption) (*DeployResourceResponse, error) {
	out := new(DeployResourceResponse)
	err := c.cc.Invoke(ctx, Gateway_DeployResource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) FailJob(ctx context.Context, in *FailJobRequest, opts ...grpc.CallOption) (*FailJobResponse, error) {
	out := new(FailJobResponse)
	err := c.cc.Invoke(ctx, Gateway_FailJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) ThrowError(ctx context.Context, in *ThrowErrorRequest, opts ...grpc.CallOption) (*ThrowErrorResponse, error) {
	out := new(ThrowErrorResponse)
	err := c.cc.Invoke(ctx, Gateway_ThrowError_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) PublishMessage(ctx context.Context, in *PublishMessageRequest, opts ...grpc.CallOption) (*PublishMessageResponse, error) {
	out := new(PublishMessageResponse)
	err := c.cc.Invoke(ctx, Gateway_PublishMessage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) ResolveIncident(ctx context.Context, in *ResolveIncidentRequest, opts ...grpc.CallOption) (*ResolveIncidentResponse, error) {
	out := new(ResolveIncidentResponse)
	err := c.cc.Invoke(ctx, Gateway_ResolveIncident_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) SetVariables(ctx context.Context, in *SetVariablesRequest, opts ...grpc.CallOption) (*SetVariablesResponse, error) {
	out := new(SetVariablesResponse)
	err := c.cc.Invoke(ctx, Gateway_SetVariables_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Topology(ctx context.Context, in *TopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	out := new(TopologyResponse)
	err := c.cc.Invoke(ctx, Gateway_Topology_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) UpdateJobRetries(ctx context.Context, in *UpdateJobRetriesRequest, opts ...grpc.CallOption) (*UpdateJobRetriesResponse, error) {
	out := new(UpdateJobRetriesResponse)
	err := c.cc.Invoke(ctx, Gateway_UpdateJobRetries_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) ModifyProcessInstance(ctx context.Context, in *ModifyProcessInstanceRequest, opts ...grpc.CallOption) (*ModifyProcessInstanceResponse, error) {
	out := new(ModifyProcessInstanceResponse)
	err := c.cc.Invoke(ctx, Gateway_ModifyProcessInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) MigrateProcessInstance(ctx context.Context, in *MigrateProcessInstanceRequest, opts ...grpc.CallOption) (*MigrateProcessInstanceResponse, error) {
	out := new(MigrateProcessInstanceResponse)
	err := c.cc.Invoke(ctx, Gateway_MigrateProcessInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) UpdateJobTimeout(ctx context.Context, in *UpdateJobTimeoutRequest, opts ...grpc.CallOption) (*UpdateJobTimeoutResponse, error) {
	out := new(UpdateJobTimeoutResponse)
	err := c.cc.Invoke(ctx, Gateway_UpdateJobTimeout_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) DeleteResource(ctx context.Context, in *DeleteResourceRequest, opts ...grpc.CallOption) (*DeleteResourceResponse, error) {
	out := new(DeleteResourceResponse)
	err := c.cc.Invoke(ctx, Gateway_DeleteResource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) BroadcastSignal(ctx context.Context, in *BroadcastSignalRequest, opts ...grpc.CallOption) (*BroadcastSignalResponse, error) {
	out := new(BroadcastSignalResponse)
	err := c.cc.Invoke(ctx, Gateway_BroadcastSignal_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServer is the server API for Gateway service.
// All implementations must embed UnimplementedGatewayServer
// for forward compatibility
type GatewayServer interface {
	// Iterates through all known partitions round-robin and activates up to the requested
	// maximum and streams them back to the client as they are activated.
	//
	// Errors:
	// INVALID_ARGUMENT:
	// - type is blank (empty string, null)
	// - worker is blank (empty string, null)
	// - timeout less than 1
	// - maxJobsToActivate is less than 1
	ActivateJobs(*ActivateJobsRequest, Gateway_ActivateJobsServer) error
	// Registers client to a job stream that will stream jobs back to the client as
	// they become activatable.
	//
	// Errors:
	// INVALID_ARGUMENT:
	// - type is blank (empty string, null)
	// - timeout less than 1
	StreamActivatedJobs(*StreamActivatedJobsRequest, Gateway_StreamActivatedJobsServer) error
	// Cancels a running process instance
	//
	// Errors:
	// NOT_FOUND:
	// - no process instance exists with the given key
	CancelProcessInstance(context.Context, *CancelProcessInstanceRequest) (*CancelProcessInstanceResponse, error)
	// Completes a job with the given variables, which allows completing the associated service task.
	//
	// Errors:
	// NOT_FOUND:
	// - no job exists with the given job key. Note that since jobs are removed once completed,
	// it could be that this job did exist at some point.
	//
	// FAILED_PRECONDITION:
	// - the job was marked as failed. In that case, the related incident must be resolved before
	// the job can be activated again and completed.
	CompleteJob(context.Context, *CompleteJobRequest) (*CompleteJobResponse, error)
	// Creates and starts an instance of the specified process. The process definition to use to
	// create the instance can be specified either using its unique key (as returned by
	// DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
	// latest deployed version. Note that only processes with none start events can be started through
	// this command.
	//
	// Errors:
	// NOT_FOUND:
	// - no process with the given key exists (if processDefinitionKey was given)
	// - no process with the given process ID exists (if bpmnProcessId was given but version was -1)
	// - no process with the given process ID and version exists (if both bpmnProcessId and version were given)
	//
	// FAILED_PRECONDITION:
	// - the process definition does not contain a none start event; only processes with none
	// start event can be started manually.
	//
	// INVALID_ARGUMENT:
	// - the given variables argument is not a valid JSON document; it is expected to be a valid
	// JSON document where the root node is an object.
	CreateProcessInstance(context.Context, *CreateProcessInstanceRequest) (*CreateProcessInstanceResponse, error)
	// Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
	CreateProcessInstanceWithResult(context.Context, *CreateProcessInstanceWithResultRequest) (*CreateProcessInstanceWithResultResponse, error)
	// Evaluates a decision. The decision to evaluate can be specified either by
	// using its unique key (as returned by DeployResource), or using the decision
	// ID. When using the decision ID, the latest deployed version of the decision
	// is used.
	//
	// Errors:
	// INVALID_ARGUMENT:
	// - no decision with the given key exists (if decisionKey was given)
	// - no decision with the given decision ID exists (if decisionId was given)
	// - both decision ID and decision KEY were provided, or are missing
	EvaluateDecision(context.Context, *EvaluateDecisionRequest) (*EvaluateDecisionResponse, error)
	// Deprecated: Do not use.
	//
	// Deploys one or more processes to Zeebe. Note that this is an atomic call,
	// i.e. either all processes are deployed, or none of them are.
	//
	// Errors:
	// INVALID_ARGUMENT:
	// - no resources given.
	// - if at least one resource is invalid. A resource is considered invalid if:
	// - the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
	// - the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
	DeployProcess(context.Context, *DeployProcessRequest) (*DeployProcessResponse, error)
	// Deploys one or more resources (e.g. processes or decision models) to Zeebe.
	// Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
	//
	// Errors:
	// PERMISSION_DENIED:
	// - if a deployment to an unauthorized tenant is performed
	// INVALID_ARGUMENT:
	// - no resources given.
	// - if at least one resource is invalid. A resource is considered invalid if:
	// - the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
	// - the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
	// - if multi-tenancy is enabled, and:
	// - a tenant id is not provided
	// - a tenant id with an invalid format is provided
	// - if multi-tenancy is disabled and a tenant id is provided
	DeployResource(context.Context, *DeployResourceRequest) (*DeployResourceResponse, error)
	// Marks the job as failed; if the retries argument is positive, then the job will be immediately
	// activatable again, and a worker could try again to process it. If it is zero or negative however,
	// an incident will be raised, tagged with the given errorMessage, and the job will not be
	// activatable until the incident is resolved.
	//
	// Errors:
	// NOT_FOUND:
	// - no job was found with the given key
	//
	// FAILED_PRECONDITION:
	// - the job was not activated
	// - the job is already in a failed state, i.e. ran out of retries
	FailJob(context.Context, *FailJobRequest) (*FailJobResponse, error)
	// Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
	//
	// Errors:
	// NOT_FOUND:
	// - no job was found with the given key
	//
	// FAILED_PRECONDITION:
	// - the job is not in an activated state
	ThrowError(context.Context, *ThrowErrorRequest) (*ThrowErrorResponse, error)
	// Publishes a single message. Messages are published to specific partitions computed from their
	// correlation keys.
	//
	// Errors:
	// ALREADY_EXISTS:
	// - a message with the same ID was previously published (and is still alive)
	PublishMessage(context.Context, *PublishMessageRequest) (*PublishMessageResponse, error)
	// Resolves a given incident. This simply marks the incident as resolved; most likely a call to
	// UpdateJobRetries or SetVariables will be necessary to actually resolve the
	// problem, following by this call.
	//
	// Errors:
	// NOT_FOUND:
	// - no incident with the given key exists
	ResolveIncident(context.Context, *ResolveIncidentRequest) (*ResolveIncidentResponse, error)
	// Updates all the variables of a particular scope (e.g. process instance, flow element instance)
	// from the given JSON document.
	//
	// Errors:
	// NOT_FOUND:
	// - no element with the given elementInstanceKey exists
	// INVALID_ARGUMENT:
	// - the given variables document is not a valid JSON document; valid documents are expected to
	// be JSON documents where the root node is an object.
	SetVariables(context.Context, *SetVariablesRequest) (*SetVariablesResponse, error)
	// Obtains the current topology of the cluster the gateway is part of.
	Topology(context.Context, *TopologyRequest) (*TopologyResponse, error)
	// Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
	// retries, should the underlying problem be solved.
	//
	// Errors:
	// NOT_FOUND:
	// - no job exists with the given key
	//
	// INVALID_ARGUMENT:
	// - retries is not greater than 0
	UpdateJobRetries(context.Context, *UpdateJobRetriesRequest) (*UpdateJobRetriesResponse, error)
	// Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
	//
	// Errors:
	// NOT_FOUND:
	// - no process instance exists with the given key
	//
	// FAILED_PRECONDITION:
	// - trying to activate element inside of a multi-instance
	//
	// INVALID_ARGUMENT:
	// - activating or terminating unknown element
	// - ancestor of element for activation doesn't exist
	// - scope of variable is unknown
	ModifyProcessInstance(context.Context, *ModifyProcessInstanceRequest) (*ModifyProcessInstanceResponse, error)
	// Migrates the process instance to the specified process definition.
	// In simple terms, this is handled by updating the active element's process.
	//
	// Errors:
	// NOT_FOUND:
	// - the process instance referenced by `processInstanceKey` is not active
	//
	// FAILED_PRECONDITION:
	// - not all active elements in the source process instance are mapped to the elements in the target process
	// - a mapping instruction changes the type of an element or event
	// - a mapping instruction refers to an unsupported element (i.e. some elements will be supported later on)
	// - a mapping instruction refers to element in unsupported scenarios.
	// (i.e. migrating active elements with event subscriptions will be supported later on)
	//
	// INVALID_ARGUMENT:
	// - the source element id does not refer to an element in the source process definition
	// - a source element id is mapped by multiple mapping instructions.
	// For example, the engine cannot determine how to migrate a process instance when the instructions are: [A->B, A->C].
	MigrateProcessInstance(context.Context, *MigrateProcessInstanceRequest) (*MigrateProcessInstanceResponse, error)
	// Updates the deadline of a job using the timeout (in ms) provided. This can be used
	// for extending or shortening the job deadline.
	//
	// Errors:
	// NOT_FOUND:
	// - no job exists with the given key
	//
	// INVALID_STATE:
	// - no deadline exists for the given job key
	UpdateJobTimeout(context.Context, *UpdateJobTimeoutRequest) (*UpdateJobTimeoutResponse, error)
	// Deletes a resource from the state. Once a resource has been deleted it cannot
	// be recovered. If the resource needs to be available again, a new deployment
	// of the resource is required.
	//
	// Deleting a process will cancel any running instances of this process
	// definition. New instances of a deleted process are created using
	// the lastest version that hasn't been deleted. Creating a new
	// process instance is impossible when all versions have been
	// deleted.
	//
	// Deleting a decision requirement definitions could cause incidents in process
	// instances referencing these decisions in a business rule task. A decision
	// will be evaluated with the latest version that hasn't been deleted. If all
	// versions of a decision have been deleted the evaluation is rejected.
	//
	// Errors:
	// NOT_FOUND:
	// - No resource exists with the given key
	DeleteResource(context.Context, *DeleteResourceRequest) (*DeleteResourceResponse, error)
	// Broadcasts a signal.
	BroadcastSignal(context.Context, *BroadcastSignalRequest) (*BroadcastSignalResponse, error)
	mustEmbedUnimplementedGatewayServer()
}

// UnimplementedGatewayServer must be embedded to have forward compatible implementations.
type UnimplementedGatewayServer struct {
}

func (UnimplementedGatewayServer) ActivateJobs(*ActivateJobsRequest, Gateway_ActivateJobsServer) error {
	return status.Errorf(codes.Unimplemented, "method ActivateJobs not implemented")
}
func (UnimplementedGatewayServer) StreamActivatedJobs(*StreamActivatedJobsRequest, Gateway_StreamActivatedJobsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamActivatedJobs not implemented")
}
func (UnimplementedGatewayServer) CancelProcessInstance(context.Context, *CancelProcessInstanceRequest) (*CancelProcessInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelProcessInstance not implemented")
}
func (UnimplementedGatewayServer) CompleteJob(context.Context, *CompleteJobRequest) (*CompleteJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteJob not implemented")
}
func (UnimplementedGatewayServer) CreateProcessInstance(context.Context, *CreateProcessInstanceRequest) (*CreateProcessInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProcessInstance not implemented")
}
func (UnimplementedGatewayServer) CreateProcessInstanceWithResult(context.Context, *CreateProcessInstanceWithResultRequest) (*CreateProcessInstanceWithResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProcessInstanceWithResult not implemented")
}
func (UnimplementedGatewayServer) EvaluateDecision(context.Context, *EvaluateDecisionRequest) (*EvaluateDecisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvaluateDecision not implemented")
}
func (UnimplementedGatewayServer) DeployProcess(context.Context, *DeployProcessRequest) (*DeployProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployProcess not implemented")
}
func (UnimplementedGatewayServer) DeployResource(context.Context, *DeployResourceRequest) (*DeployResourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployResource not implemented")
}
func (UnimplementedGatewayServer) FailJob(context.Context, *FailJobRequest) (*FailJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FailJob not implemented")
}
func (UnimplementedGatewayServer) ThrowError(context.Context, *ThrowErrorRequest) (*ThrowErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ThrowError not implemented")
}
func (UnimplementedGatewayServer) PublishMessage(context.Context, *PublishMessageRequest) (*PublishMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishMessage not implemented")
}
func (UnimplementedGatewayServer) ResolveIncident(context.Context, *ResolveIncidentRequest) (*ResolveIncidentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveIncident not implemented")
}
func (UnimplementedGatewayServer) SetVariables(context.Context, *SetVariablesRequest) (*SetVariablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVariables not implemented")
}
func (UnimplementedGatewayServer) Topology(context.Context, *TopologyRequest) (*TopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Topology not implemented")
}
func (UnimplementedGatewayServer) UpdateJobRetries(context.Context, *UpdateJobRetriesRequest) (*UpdateJobRetriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateJobRetries not implemented")
}
func (UnimplementedGatewayServer) ModifyProcessInstance(context.Context, *ModifyProcessInstanceRequest) (*ModifyProcessInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyProcessInstance not implemented")
}
func (UnimplementedGatewayServer) MigrateProcessInstance(context.Context, *MigrateProcessInstanceRequest) (*MigrateProcessInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateProcessInstance not implemented")
}
func (UnimplementedGatewayServer) UpdateJobTimeout(context.Context, *UpdateJobTimeoutRequest) (*UpdateJobTimeoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateJobTimeout not implemented")
}
func (UnimplementedGatewayServer) DeleteResource(context.Context, *DeleteResourceRequest) (*DeleteResourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteResource not implemented")
}
func (UnimplementedGatewayServer) BroadcastSignal(context.Context, *BroadcastSignalRequest) (*BroadcastSignalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastSignal not implemented")
}
func (UnimplementedGatewayServer) mustEmbedUnimplementedGatewayServer() {}

// UnsafeGatewayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GatewayServer will
// result in compilation errors.
type UnsafeGatewayServer interface {
	mustEmbedUnimplementedGatewayServer()
}

func RegisterGatewayServer(s grpc.ServiceRegistrar, srv GatewayServer) {
	s.RegisterService(&Gateway_ServiceDesc, srv)
}

func _Gateway_ActivateJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ActivateJobsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GatewayServer).ActivateJobs(m, &gatewayActivateJobsServer{stream})
}

type Gateway_ActivateJobsServer interface {
	Send(*ActivateJobsResponse) error
	grpc.ServerStream
}

type gatewayActivateJobsServer struct {
	grpc.ServerStream
}

func (x *gatewayActivateJobsServer) Send(m *ActivateJobsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Gateway_StreamActivatedJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamActivatedJobsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GatewayServer).StreamActivatedJobs(m, &gatewayStreamActivatedJobsServer{stream})
}

type Gateway_StreamActivatedJobsServer interface {
	Send(*ActivatedJob) error
	grpc.ServerStream
}

type gatewayStreamActivatedJobsServer struct {
	grpc.ServerStream
}

func (x *gatewayStreamActivatedJobsServer) Send(m *ActivatedJob) error {
	return x.ServerStream.SendMsg(m)
}

func _Gateway_CancelProcessInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelProcessInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CancelProcessInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_CancelProcessInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CancelProcessInstance(ctx, req.(*CancelProcessInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_CompleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CompleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_CompleteJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CompleteJob(ctx, req.(*CompleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_CreateProcessInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProcessInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CreateProcessInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_CreateProcessInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CreateProcessInstance(ctx, req.(*CreateProcessInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_CreateProcessInstanceWithResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProcessInstanceWithResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CreateProcessInstanceWithResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_CreateProcessInstanceWithResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CreateProcessInstanceWithResult(ctx, req.(*CreateProcessInstanceWithResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_EvaluateDecision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluateDecisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).EvaluateDecision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_EvaluateDecision_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).EvaluateDecision(ctx, req.(*EvaluateDecisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_DeployProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).DeployProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_DeployProcess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).DeployProcess(ctx, req.(*DeployProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_DeployResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).DeployResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_DeployResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).DeployResource(ctx, req.(*DeployResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_FailJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).FailJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_FailJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).FailJob(ctx, req.(*FailJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_ThrowError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ThrowErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).ThrowError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_ThrowError_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).ThrowError(ctx, req.(*ThrowErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_PublishMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).PublishMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_PublishMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).PublishMessage(ctx, req.(*PublishMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_ResolveIncident_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveIncidentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).ResolveIncident(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_ResolveIncident_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).ResolveIncident(ctx, req.(*ResolveIncidentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_SetVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).SetVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_SetVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).SetVariables(ctx, req.(*SetVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Topology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Topology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_Topology_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Topology(ctx, req.(*TopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_UpdateJobRetries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJobRetriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).UpdateJobRetries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_UpdateJobRetries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).UpdateJobRetries(ctx, req.(*UpdateJobRetriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_ModifyProcessInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyProcessInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).ModifyProcessInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_ModifyProcessInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).ModifyProcessInstance(ctx, req.(*ModifyProcessInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_MigrateProcessInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateProcessInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).MigrateProcessInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_MigrateProcessInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).MigrateProcessInstance(ctx, req.(*MigrateProcessInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_UpdateJobTimeout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJobTimeoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).UpdateJobTimeout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_UpdateJobTimeout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).UpdateJobTimeout(ctx, req.(*UpdateJobTimeoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_DeleteResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).DeleteResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_DeleteResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).DeleteResource(ctx, req.(*DeleteResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_BroadcastSignal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastSignalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).BroadcastSignal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Gateway_BroadcastSignal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).BroadcastSignal(ctx, req.(*BroadcastSignalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Gateway_ServiceDesc is the grpc.ServiceDesc for Gateway service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Gateway_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gateway_protocol.Gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CancelProcessInstance",
			Handler:    _Gateway_CancelProcessInstance_Handler,
		},
		{
			MethodName: "CompleteJob",
			Handler:    _Gateway_CompleteJob_Handler,
		},
		{
			MethodName: "CreateProcessInstance",
			Handler:    _Gateway_CreateProcessInstance_Handler,
		},
		{
			MethodName: "CreateProcessInstanceWithResult",
			Handler:    _Gateway_CreateProcessInstanceWithResult_Handler,
		},
		{
			MethodName: "EvaluateDecision",
			Handler:    _Gateway_EvaluateDecision_Handler,
		},
		{
			MethodName: "DeployProcess",
			Handler:    _Gateway_DeployProcess_Handler,
		},
		{
			MethodName: "DeployResource",
			Handler:    _Gateway_DeployResource_Handler,
		},
		{
			MethodName: "FailJob",
			Handler:    _Gateway_FailJob_Handler,
		},
		{
			MethodName: "ThrowError",
			Handler:    _Gateway_ThrowError_Handler,
		},
		{
			MethodName: "PublishMessage",
			Handler:    _Gateway_PublishMessage_Handler,
		},
		{
			MethodName: "ResolveIncident",
			Handler:    _Gateway_ResolveIncident_Handler,
		},
		{
			MethodName: "SetVariables",
			Handler:    _Gateway_SetVariables_Handler,
		},
		{
			MethodName: "Topology",
			Handler:    _Gateway_Topology_Handler,
		},
		{
			MethodName: "UpdateJobRetries",
			Handler:    _Gateway_UpdateJobRetries_Handler,
		},
		{
			MethodName: "ModifyProcessInstance",
			Handler:    _Gateway_ModifyProcessInstance_Handler,
		},
		{
			MethodName: "MigrateProcessInstance",
			Handler:    _Gateway_MigrateProcessInstance_Handler,
		},
		{
			MethodName: "UpdateJobTimeout",
			Handler:    _Gateway_UpdateJobTimeout_Handler,
		},
		{
			MethodName: "DeleteResource",
			Handler:    _Gateway_DeleteResource_Handler,
		},
		{
			MethodName: "BroadcastSignal",
			Handler:    _Gateway_BroadcastSignal_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ActivateJobs",
			Handler:       _Gateway_ActivateJobs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamActivatedJobs",
			Handler:       _Gateway_StreamActivatedJobs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gateway.proto",
}
